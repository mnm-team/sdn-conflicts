# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

class yc_proxyConfigs_sdn_testbed_spec__testbed_apps_eplb_configs_proxyConfigs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module sdn_testbed_spec - based on the path /testbed/apps/eplb/configs/proxyConfigs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__proxy','__servers',)

  _yang_name = 'proxyConfigs'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__proxy = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'pc[0-9]{1,2}'}), is_leaf=True, yang_name="proxy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='hostId', is_config=True)
    self.__servers = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'pc[0-9]{1,2}'})), is_leaf=False, yang_name="servers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='hostId', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['testbed', 'apps', 'eplb', 'configs', 'proxyConfigs']

  def _get_proxy(self):
    """
    Getter method for proxy, mapped from YANG variable /testbed/apps/eplb/configs/proxyConfigs/proxy (hostId)
    """
    return self.__proxy
      
  def _set_proxy(self, v, load=False):
    """
    Setter method for proxy, mapped from YANG variable /testbed/apps/eplb/configs/proxyConfigs/proxy (hostId)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_proxy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_proxy() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'pc[0-9]{1,2}'}), is_leaf=True, yang_name="proxy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='hostId', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """proxy must be of a type compatible with hostId""",
          'defined-type': "sdn_testbed_spec:hostId",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'pc[0-9]{1,2}'}), is_leaf=True, yang_name="proxy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='hostId', is_config=True)""",
        })

    self.__proxy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_proxy(self):
    self.__proxy = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'pc[0-9]{1,2}'}), is_leaf=True, yang_name="proxy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='hostId', is_config=True)


  def _get_servers(self):
    """
    Getter method for servers, mapped from YANG variable /testbed/apps/eplb/configs/proxyConfigs/servers (hostId)
    """
    return self.__servers
      
  def _set_servers(self, v, load=False):
    """
    Setter method for servers, mapped from YANG variable /testbed/apps/eplb/configs/proxyConfigs/servers (hostId)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_servers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_servers() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'pc[0-9]{1,2}'})), is_leaf=False, yang_name="servers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='hostId', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """servers must be of a type compatible with hostId""",
          'defined-type': "sdn_testbed_spec:hostId",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'pc[0-9]{1,2}'})), is_leaf=False, yang_name="servers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='hostId', is_config=True)""",
        })

    self.__servers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_servers(self):
    self.__servers = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'pc[0-9]{1,2}'})), is_leaf=False, yang_name="servers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='hostId', is_config=True)

  proxy = __builtin__.property(_get_proxy, _set_proxy)
  servers = __builtin__.property(_get_servers, _set_servers)


  _pyangbind_elements = OrderedDict([('proxy', proxy), ('servers', servers), ])


class yc_configs_sdn_testbed_spec__testbed_apps_eplb_configs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module sdn_testbed_spec - based on the path /testbed/apps/eplb/configs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__proxyConfigs',)

  _yang_name = 'configs'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='uint8', is_config=True)
    self.__proxyConfigs = YANGDynClass(base=YANGListType("proxy",yc_proxyConfigs_sdn_testbed_spec__testbed_apps_eplb_configs_proxyConfigs, yang_name="proxyConfigs", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='proxy', extensions=None), is_container='list', yang_name="proxyConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['testbed', 'apps', 'eplb', 'configs']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /testbed/apps/eplb/configs/id (uint8)
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /testbed/apps/eplb/configs/id (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='uint8', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='uint8', is_config=True)


  def _get_proxyConfigs(self):
    """
    Getter method for proxyConfigs, mapped from YANG variable /testbed/apps/eplb/configs/proxyConfigs (list)
    """
    return self.__proxyConfigs
      
  def _set_proxyConfigs(self, v, load=False):
    """
    Setter method for proxyConfigs, mapped from YANG variable /testbed/apps/eplb/configs/proxyConfigs (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_proxyConfigs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_proxyConfigs() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("proxy",yc_proxyConfigs_sdn_testbed_spec__testbed_apps_eplb_configs_proxyConfigs, yang_name="proxyConfigs", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='proxy', extensions=None), is_container='list', yang_name="proxyConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """proxyConfigs must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("proxy",yc_proxyConfigs_sdn_testbed_spec__testbed_apps_eplb_configs_proxyConfigs, yang_name="proxyConfigs", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='proxy', extensions=None), is_container='list', yang_name="proxyConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='list', is_config=True)""",
        })

    self.__proxyConfigs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_proxyConfigs(self):
    self.__proxyConfigs = YANGDynClass(base=YANGListType("proxy",yc_proxyConfigs_sdn_testbed_spec__testbed_apps_eplb_configs_proxyConfigs, yang_name="proxyConfigs", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='proxy', extensions=None), is_container='list', yang_name="proxyConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='list', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  proxyConfigs = __builtin__.property(_get_proxyConfigs, _set_proxyConfigs)


  _pyangbind_elements = OrderedDict([('id', id), ('proxyConfigs', proxyConfigs), ])


class yc_eplb_sdn_testbed_spec__testbed_apps_eplb(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module sdn_testbed_spec - based on the path /testbed/apps/eplb. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__targetSwitches','__configs',)

  _yang_name = 'eplb'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__targetSwitches = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}'})), is_leaf=False, yang_name="targetSwitches", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='switchId', is_config=True)
    self.__configs = YANGDynClass(base=YANGListType("id",yc_configs_sdn_testbed_spec__testbed_apps_eplb_configs, yang_name="configs", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="configs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['testbed', 'apps', 'eplb']

  def _get_targetSwitches(self):
    """
    Getter method for targetSwitches, mapped from YANG variable /testbed/apps/eplb/targetSwitches (switchId)
    """
    return self.__targetSwitches
      
  def _set_targetSwitches(self, v, load=False):
    """
    Setter method for targetSwitches, mapped from YANG variable /testbed/apps/eplb/targetSwitches (switchId)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_targetSwitches is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_targetSwitches() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}'})), is_leaf=False, yang_name="targetSwitches", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='switchId', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """targetSwitches must be of a type compatible with switchId""",
          'defined-type': "sdn_testbed_spec:switchId",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}'})), is_leaf=False, yang_name="targetSwitches", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='switchId', is_config=True)""",
        })

    self.__targetSwitches = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_targetSwitches(self):
    self.__targetSwitches = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}'})), is_leaf=False, yang_name="targetSwitches", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='switchId', is_config=True)


  def _get_configs(self):
    """
    Getter method for configs, mapped from YANG variable /testbed/apps/eplb/configs (list)
    """
    return self.__configs
      
  def _set_configs(self, v, load=False):
    """
    Setter method for configs, mapped from YANG variable /testbed/apps/eplb/configs (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_configs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_configs() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_configs_sdn_testbed_spec__testbed_apps_eplb_configs, yang_name="configs", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="configs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """configs must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_configs_sdn_testbed_spec__testbed_apps_eplb_configs, yang_name="configs", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="configs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='list', is_config=True)""",
        })

    self.__configs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_configs(self):
    self.__configs = YANGDynClass(base=YANGListType("id",yc_configs_sdn_testbed_spec__testbed_apps_eplb_configs, yang_name="configs", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="configs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='list', is_config=True)

  targetSwitches = __builtin__.property(_get_targetSwitches, _set_targetSwitches)
  configs = __builtin__.property(_get_configs, _set_configs)


  _pyangbind_elements = OrderedDict([('targetSwitches', targetSwitches), ('configs', configs), ])


class yc_invariantsConfigs_sdn_testbed_spec__testbed_apps_plb_configs_invariantsConfigs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module sdn_testbed_spec - based on the path /testbed/apps/plb/configs/invariantsConfigs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__targetSwitch','__bw_threshold','__excluded_ports',)

  _yang_name = 'invariantsConfigs'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__targetSwitch = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}'}), is_leaf=True, yang_name="targetSwitch", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='switchId', is_config=True)
    self.__bw_threshold = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="bw_threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='uint8', is_config=True)
    self.__excluded_ports = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="excluded_ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='uint8', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['testbed', 'apps', 'plb', 'configs', 'invariantsConfigs']

  def _get_targetSwitch(self):
    """
    Getter method for targetSwitch, mapped from YANG variable /testbed/apps/plb/configs/invariantsConfigs/targetSwitch (switchId)
    """
    return self.__targetSwitch
      
  def _set_targetSwitch(self, v, load=False):
    """
    Setter method for targetSwitch, mapped from YANG variable /testbed/apps/plb/configs/invariantsConfigs/targetSwitch (switchId)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_targetSwitch is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_targetSwitch() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}'}), is_leaf=True, yang_name="targetSwitch", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='switchId', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """targetSwitch must be of a type compatible with switchId""",
          'defined-type': "sdn_testbed_spec:switchId",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}'}), is_leaf=True, yang_name="targetSwitch", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='switchId', is_config=True)""",
        })

    self.__targetSwitch = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_targetSwitch(self):
    self.__targetSwitch = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}'}), is_leaf=True, yang_name="targetSwitch", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='switchId', is_config=True)


  def _get_bw_threshold(self):
    """
    Getter method for bw_threshold, mapped from YANG variable /testbed/apps/plb/configs/invariantsConfigs/bw_threshold (uint8)
    """
    return self.__bw_threshold
      
  def _set_bw_threshold(self, v, load=False):
    """
    Setter method for bw_threshold, mapped from YANG variable /testbed/apps/plb/configs/invariantsConfigs/bw_threshold (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bw_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bw_threshold() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="bw_threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bw_threshold must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="bw_threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='uint8', is_config=True)""",
        })

    self.__bw_threshold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bw_threshold(self):
    self.__bw_threshold = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="bw_threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='uint8', is_config=True)


  def _get_excluded_ports(self):
    """
    Getter method for excluded_ports, mapped from YANG variable /testbed/apps/plb/configs/invariantsConfigs/excluded_ports (uint8)
    """
    return self.__excluded_ports
      
  def _set_excluded_ports(self, v, load=False):
    """
    Setter method for excluded_ports, mapped from YANG variable /testbed/apps/plb/configs/invariantsConfigs/excluded_ports (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_excluded_ports is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_excluded_ports() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="excluded_ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """excluded_ports must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="excluded_ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='uint8', is_config=True)""",
        })

    self.__excluded_ports = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_excluded_ports(self):
    self.__excluded_ports = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="excluded_ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='uint8', is_config=True)

  targetSwitch = __builtin__.property(_get_targetSwitch, _set_targetSwitch)
  bw_threshold = __builtin__.property(_get_bw_threshold, _set_bw_threshold)
  excluded_ports = __builtin__.property(_get_excluded_ports, _set_excluded_ports)


  _pyangbind_elements = OrderedDict([('targetSwitch', targetSwitch), ('bw_threshold', bw_threshold), ('excluded_ports', excluded_ports), ])


class yc_configs_sdn_testbed_spec__testbed_apps_plb_configs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module sdn_testbed_spec - based on the path /testbed/apps/plb/configs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__bw_time','__invariantsConfigs',)

  _yang_name = 'configs'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='uint8', is_config=True)
    self.__bw_time = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="bw_time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='uint8', is_config=True)
    self.__invariantsConfigs = YANGDynClass(base=YANGListType("targetSwitch",yc_invariantsConfigs_sdn_testbed_spec__testbed_apps_plb_configs_invariantsConfigs, yang_name="invariantsConfigs", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='targetSwitch', extensions=None), is_container='list', yang_name="invariantsConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['testbed', 'apps', 'plb', 'configs']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /testbed/apps/plb/configs/id (uint8)
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /testbed/apps/plb/configs/id (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='uint8', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='uint8', is_config=True)


  def _get_bw_time(self):
    """
    Getter method for bw_time, mapped from YANG variable /testbed/apps/plb/configs/bw_time (uint8)
    """
    return self.__bw_time
      
  def _set_bw_time(self, v, load=False):
    """
    Setter method for bw_time, mapped from YANG variable /testbed/apps/plb/configs/bw_time (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bw_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bw_time() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="bw_time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bw_time must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="bw_time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='uint8', is_config=True)""",
        })

    self.__bw_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bw_time(self):
    self.__bw_time = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="bw_time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='uint8', is_config=True)


  def _get_invariantsConfigs(self):
    """
    Getter method for invariantsConfigs, mapped from YANG variable /testbed/apps/plb/configs/invariantsConfigs (list)
    """
    return self.__invariantsConfigs
      
  def _set_invariantsConfigs(self, v, load=False):
    """
    Setter method for invariantsConfigs, mapped from YANG variable /testbed/apps/plb/configs/invariantsConfigs (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_invariantsConfigs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_invariantsConfigs() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("targetSwitch",yc_invariantsConfigs_sdn_testbed_spec__testbed_apps_plb_configs_invariantsConfigs, yang_name="invariantsConfigs", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='targetSwitch', extensions=None), is_container='list', yang_name="invariantsConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """invariantsConfigs must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("targetSwitch",yc_invariantsConfigs_sdn_testbed_spec__testbed_apps_plb_configs_invariantsConfigs, yang_name="invariantsConfigs", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='targetSwitch', extensions=None), is_container='list', yang_name="invariantsConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='list', is_config=True)""",
        })

    self.__invariantsConfigs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_invariantsConfigs(self):
    self.__invariantsConfigs = YANGDynClass(base=YANGListType("targetSwitch",yc_invariantsConfigs_sdn_testbed_spec__testbed_apps_plb_configs_invariantsConfigs, yang_name="invariantsConfigs", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='targetSwitch', extensions=None), is_container='list', yang_name="invariantsConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='list', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  bw_time = __builtin__.property(_get_bw_time, _set_bw_time)
  invariantsConfigs = __builtin__.property(_get_invariantsConfigs, _set_invariantsConfigs)


  _pyangbind_elements = OrderedDict([('id', id), ('bw_time', bw_time), ('invariantsConfigs', invariantsConfigs), ])


class yc_plb_sdn_testbed_spec__testbed_apps_plb(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module sdn_testbed_spec - based on the path /testbed/apps/plb. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__configs',)

  _yang_name = 'plb'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__configs = YANGDynClass(base=YANGListType("id",yc_configs_sdn_testbed_spec__testbed_apps_plb_configs, yang_name="configs", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="configs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['testbed', 'apps', 'plb']

  def _get_configs(self):
    """
    Getter method for configs, mapped from YANG variable /testbed/apps/plb/configs (list)
    """
    return self.__configs
      
  def _set_configs(self, v, load=False):
    """
    Setter method for configs, mapped from YANG variable /testbed/apps/plb/configs (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_configs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_configs() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_configs_sdn_testbed_spec__testbed_apps_plb_configs, yang_name="configs", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="configs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """configs must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_configs_sdn_testbed_spec__testbed_apps_plb_configs, yang_name="configs", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="configs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='list', is_config=True)""",
        })

    self.__configs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_configs(self):
    self.__configs = YANGDynClass(base=YANGListType("id",yc_configs_sdn_testbed_spec__testbed_apps_plb_configs, yang_name="configs", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="configs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='list', is_config=True)

  configs = __builtin__.property(_get_configs, _set_configs)


  _pyangbind_elements = OrderedDict([('configs', configs), ])


class yc_invariantsConfigs_sdn_testbed_spec__testbed_apps_fw_configs_invariantsConfigs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module sdn_testbed_spec - based on the path /testbed/apps/fw/configs/invariantsConfigs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__targetSwitch','__bw_port_threshold','__bw_flow_threshold',)

  _yang_name = 'invariantsConfigs'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__targetSwitch = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}'}), is_leaf=True, yang_name="targetSwitch", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='switchId', is_config=True)
    self.__bw_port_threshold = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="bw_port_threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='uint8', is_config=True)
    self.__bw_flow_threshold = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="bw_flow_threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='uint8', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['testbed', 'apps', 'fw', 'configs', 'invariantsConfigs']

  def _get_targetSwitch(self):
    """
    Getter method for targetSwitch, mapped from YANG variable /testbed/apps/fw/configs/invariantsConfigs/targetSwitch (switchId)
    """
    return self.__targetSwitch
      
  def _set_targetSwitch(self, v, load=False):
    """
    Setter method for targetSwitch, mapped from YANG variable /testbed/apps/fw/configs/invariantsConfigs/targetSwitch (switchId)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_targetSwitch is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_targetSwitch() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}'}), is_leaf=True, yang_name="targetSwitch", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='switchId', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """targetSwitch must be of a type compatible with switchId""",
          'defined-type': "sdn_testbed_spec:switchId",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}'}), is_leaf=True, yang_name="targetSwitch", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='switchId', is_config=True)""",
        })

    self.__targetSwitch = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_targetSwitch(self):
    self.__targetSwitch = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}'}), is_leaf=True, yang_name="targetSwitch", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='switchId', is_config=True)


  def _get_bw_port_threshold(self):
    """
    Getter method for bw_port_threshold, mapped from YANG variable /testbed/apps/fw/configs/invariantsConfigs/bw_port_threshold (uint8)
    """
    return self.__bw_port_threshold
      
  def _set_bw_port_threshold(self, v, load=False):
    """
    Setter method for bw_port_threshold, mapped from YANG variable /testbed/apps/fw/configs/invariantsConfigs/bw_port_threshold (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bw_port_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bw_port_threshold() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="bw_port_threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bw_port_threshold must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="bw_port_threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='uint8', is_config=True)""",
        })

    self.__bw_port_threshold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bw_port_threshold(self):
    self.__bw_port_threshold = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="bw_port_threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='uint8', is_config=True)


  def _get_bw_flow_threshold(self):
    """
    Getter method for bw_flow_threshold, mapped from YANG variable /testbed/apps/fw/configs/invariantsConfigs/bw_flow_threshold (uint8)
    """
    return self.__bw_flow_threshold
      
  def _set_bw_flow_threshold(self, v, load=False):
    """
    Setter method for bw_flow_threshold, mapped from YANG variable /testbed/apps/fw/configs/invariantsConfigs/bw_flow_threshold (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bw_flow_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bw_flow_threshold() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="bw_flow_threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bw_flow_threshold must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="bw_flow_threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='uint8', is_config=True)""",
        })

    self.__bw_flow_threshold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bw_flow_threshold(self):
    self.__bw_flow_threshold = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="bw_flow_threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='uint8', is_config=True)

  targetSwitch = __builtin__.property(_get_targetSwitch, _set_targetSwitch)
  bw_port_threshold = __builtin__.property(_get_bw_port_threshold, _set_bw_port_threshold)
  bw_flow_threshold = __builtin__.property(_get_bw_flow_threshold, _set_bw_flow_threshold)


  _pyangbind_elements = OrderedDict([('targetSwitch', targetSwitch), ('bw_port_threshold', bw_port_threshold), ('bw_flow_threshold', bw_flow_threshold), ])


class yc_configs_sdn_testbed_spec__testbed_apps_fw_configs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module sdn_testbed_spec - based on the path /testbed/apps/fw/configs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__bw_time','__invariantsConfigs',)

  _yang_name = 'configs'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='uint8', is_config=True)
    self.__bw_time = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="bw_time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='uint8', is_config=True)
    self.__invariantsConfigs = YANGDynClass(base=YANGListType("targetSwitch",yc_invariantsConfigs_sdn_testbed_spec__testbed_apps_fw_configs_invariantsConfigs, yang_name="invariantsConfigs", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='targetSwitch', extensions=None), is_container='list', yang_name="invariantsConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['testbed', 'apps', 'fw', 'configs']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /testbed/apps/fw/configs/id (uint8)
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /testbed/apps/fw/configs/id (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='uint8', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='uint8', is_config=True)


  def _get_bw_time(self):
    """
    Getter method for bw_time, mapped from YANG variable /testbed/apps/fw/configs/bw_time (uint8)
    """
    return self.__bw_time
      
  def _set_bw_time(self, v, load=False):
    """
    Setter method for bw_time, mapped from YANG variable /testbed/apps/fw/configs/bw_time (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bw_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bw_time() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="bw_time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bw_time must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="bw_time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='uint8', is_config=True)""",
        })

    self.__bw_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bw_time(self):
    self.__bw_time = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="bw_time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='uint8', is_config=True)


  def _get_invariantsConfigs(self):
    """
    Getter method for invariantsConfigs, mapped from YANG variable /testbed/apps/fw/configs/invariantsConfigs (list)
    """
    return self.__invariantsConfigs
      
  def _set_invariantsConfigs(self, v, load=False):
    """
    Setter method for invariantsConfigs, mapped from YANG variable /testbed/apps/fw/configs/invariantsConfigs (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_invariantsConfigs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_invariantsConfigs() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("targetSwitch",yc_invariantsConfigs_sdn_testbed_spec__testbed_apps_fw_configs_invariantsConfigs, yang_name="invariantsConfigs", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='targetSwitch', extensions=None), is_container='list', yang_name="invariantsConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """invariantsConfigs must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("targetSwitch",yc_invariantsConfigs_sdn_testbed_spec__testbed_apps_fw_configs_invariantsConfigs, yang_name="invariantsConfigs", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='targetSwitch', extensions=None), is_container='list', yang_name="invariantsConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='list', is_config=True)""",
        })

    self.__invariantsConfigs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_invariantsConfigs(self):
    self.__invariantsConfigs = YANGDynClass(base=YANGListType("targetSwitch",yc_invariantsConfigs_sdn_testbed_spec__testbed_apps_fw_configs_invariantsConfigs, yang_name="invariantsConfigs", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='targetSwitch', extensions=None), is_container='list', yang_name="invariantsConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='list', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  bw_time = __builtin__.property(_get_bw_time, _set_bw_time)
  invariantsConfigs = __builtin__.property(_get_invariantsConfigs, _set_invariantsConfigs)


  _pyangbind_elements = OrderedDict([('id', id), ('bw_time', bw_time), ('invariantsConfigs', invariantsConfigs), ])


class yc_fw_sdn_testbed_spec__testbed_apps_fw(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module sdn_testbed_spec - based on the path /testbed/apps/fw. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__configs',)

  _yang_name = 'fw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__configs = YANGDynClass(base=YANGListType("id",yc_configs_sdn_testbed_spec__testbed_apps_fw_configs, yang_name="configs", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="configs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['testbed', 'apps', 'fw']

  def _get_configs(self):
    """
    Getter method for configs, mapped from YANG variable /testbed/apps/fw/configs (list)
    """
    return self.__configs
      
  def _set_configs(self, v, load=False):
    """
    Setter method for configs, mapped from YANG variable /testbed/apps/fw/configs (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_configs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_configs() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_configs_sdn_testbed_spec__testbed_apps_fw_configs, yang_name="configs", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="configs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """configs must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_configs_sdn_testbed_spec__testbed_apps_fw_configs, yang_name="configs", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="configs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='list', is_config=True)""",
        })

    self.__configs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_configs(self):
    self.__configs = YANGDynClass(base=YANGListType("id",yc_configs_sdn_testbed_spec__testbed_apps_fw_configs, yang_name="configs", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="configs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='list', is_config=True)

  configs = __builtin__.property(_get_configs, _set_configs)


  _pyangbind_elements = OrderedDict([('configs', configs), ])


class yc_configs_sdn_testbed_spec__testbed_apps_pplb4d_configs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module sdn_testbed_spec - based on the path /testbed/apps/pplb4d/configs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__servers',)

  _yang_name = 'configs'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='uint8', is_config=True)
    self.__servers = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'pc[0-9]{1,2}'})), is_leaf=False, yang_name="servers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='hostId', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['testbed', 'apps', 'pplb4d', 'configs']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /testbed/apps/pplb4d/configs/id (uint8)
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /testbed/apps/pplb4d/configs/id (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='uint8', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='uint8', is_config=True)


  def _get_servers(self):
    """
    Getter method for servers, mapped from YANG variable /testbed/apps/pplb4d/configs/servers (hostId)
    """
    return self.__servers
      
  def _set_servers(self, v, load=False):
    """
    Setter method for servers, mapped from YANG variable /testbed/apps/pplb4d/configs/servers (hostId)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_servers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_servers() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'pc[0-9]{1,2}'})), is_leaf=False, yang_name="servers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='hostId', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """servers must be of a type compatible with hostId""",
          'defined-type': "sdn_testbed_spec:hostId",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'pc[0-9]{1,2}'})), is_leaf=False, yang_name="servers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='hostId', is_config=True)""",
        })

    self.__servers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_servers(self):
    self.__servers = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'pc[0-9]{1,2}'})), is_leaf=False, yang_name="servers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='hostId', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  servers = __builtin__.property(_get_servers, _set_servers)


  _pyangbind_elements = OrderedDict([('id', id), ('servers', servers), ])


class yc_pplb4d_sdn_testbed_spec__testbed_apps_pplb4d(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module sdn_testbed_spec - based on the path /testbed/apps/pplb4d. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__targetSwitches','__configs',)

  _yang_name = 'pplb4d'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__targetSwitches = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}'})), is_leaf=False, yang_name="targetSwitches", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='switchId', is_config=True)
    self.__configs = YANGDynClass(base=YANGListType("id",yc_configs_sdn_testbed_spec__testbed_apps_pplb4d_configs, yang_name="configs", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="configs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['testbed', 'apps', 'pplb4d']

  def _get_targetSwitches(self):
    """
    Getter method for targetSwitches, mapped from YANG variable /testbed/apps/pplb4d/targetSwitches (switchId)
    """
    return self.__targetSwitches
      
  def _set_targetSwitches(self, v, load=False):
    """
    Setter method for targetSwitches, mapped from YANG variable /testbed/apps/pplb4d/targetSwitches (switchId)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_targetSwitches is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_targetSwitches() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}'})), is_leaf=False, yang_name="targetSwitches", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='switchId', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """targetSwitches must be of a type compatible with switchId""",
          'defined-type': "sdn_testbed_spec:switchId",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}'})), is_leaf=False, yang_name="targetSwitches", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='switchId', is_config=True)""",
        })

    self.__targetSwitches = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_targetSwitches(self):
    self.__targetSwitches = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}'})), is_leaf=False, yang_name="targetSwitches", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='switchId', is_config=True)


  def _get_configs(self):
    """
    Getter method for configs, mapped from YANG variable /testbed/apps/pplb4d/configs (list)
    """
    return self.__configs
      
  def _set_configs(self, v, load=False):
    """
    Setter method for configs, mapped from YANG variable /testbed/apps/pplb4d/configs (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_configs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_configs() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_configs_sdn_testbed_spec__testbed_apps_pplb4d_configs, yang_name="configs", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="configs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """configs must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_configs_sdn_testbed_spec__testbed_apps_pplb4d_configs, yang_name="configs", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="configs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='list', is_config=True)""",
        })

    self.__configs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_configs(self):
    self.__configs = YANGDynClass(base=YANGListType("id",yc_configs_sdn_testbed_spec__testbed_apps_pplb4d_configs, yang_name="configs", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="configs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='list', is_config=True)

  targetSwitches = __builtin__.property(_get_targetSwitches, _set_targetSwitches)
  configs = __builtin__.property(_get_configs, _set_configs)


  _pyangbind_elements = OrderedDict([('targetSwitches', targetSwitches), ('configs', configs), ])


class yc_configs_sdn_testbed_spec__testbed_apps_pplb4s_configs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module sdn_testbed_spec - based on the path /testbed/apps/pplb4s/configs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__servers',)

  _yang_name = 'configs'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='uint8', is_config=True)
    self.__servers = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'pc[0-9]{1,2}'})), is_leaf=False, yang_name="servers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='hostId', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['testbed', 'apps', 'pplb4s', 'configs']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /testbed/apps/pplb4s/configs/id (uint8)
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /testbed/apps/pplb4s/configs/id (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='uint8', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='uint8', is_config=True)


  def _get_servers(self):
    """
    Getter method for servers, mapped from YANG variable /testbed/apps/pplb4s/configs/servers (hostId)
    """
    return self.__servers
      
  def _set_servers(self, v, load=False):
    """
    Setter method for servers, mapped from YANG variable /testbed/apps/pplb4s/configs/servers (hostId)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_servers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_servers() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'pc[0-9]{1,2}'})), is_leaf=False, yang_name="servers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='hostId', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """servers must be of a type compatible with hostId""",
          'defined-type': "sdn_testbed_spec:hostId",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'pc[0-9]{1,2}'})), is_leaf=False, yang_name="servers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='hostId', is_config=True)""",
        })

    self.__servers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_servers(self):
    self.__servers = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'pc[0-9]{1,2}'})), is_leaf=False, yang_name="servers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='hostId', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  servers = __builtin__.property(_get_servers, _set_servers)


  _pyangbind_elements = OrderedDict([('id', id), ('servers', servers), ])


class yc_pplb4s_sdn_testbed_spec__testbed_apps_pplb4s(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module sdn_testbed_spec - based on the path /testbed/apps/pplb4s. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__targetSwitches','__configs',)

  _yang_name = 'pplb4s'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__targetSwitches = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}'})), is_leaf=False, yang_name="targetSwitches", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='switchId', is_config=True)
    self.__configs = YANGDynClass(base=YANGListType("id",yc_configs_sdn_testbed_spec__testbed_apps_pplb4s_configs, yang_name="configs", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="configs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['testbed', 'apps', 'pplb4s']

  def _get_targetSwitches(self):
    """
    Getter method for targetSwitches, mapped from YANG variable /testbed/apps/pplb4s/targetSwitches (switchId)
    """
    return self.__targetSwitches
      
  def _set_targetSwitches(self, v, load=False):
    """
    Setter method for targetSwitches, mapped from YANG variable /testbed/apps/pplb4s/targetSwitches (switchId)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_targetSwitches is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_targetSwitches() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}'})), is_leaf=False, yang_name="targetSwitches", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='switchId', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """targetSwitches must be of a type compatible with switchId""",
          'defined-type': "sdn_testbed_spec:switchId",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}'})), is_leaf=False, yang_name="targetSwitches", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='switchId', is_config=True)""",
        })

    self.__targetSwitches = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_targetSwitches(self):
    self.__targetSwitches = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}'})), is_leaf=False, yang_name="targetSwitches", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='switchId', is_config=True)


  def _get_configs(self):
    """
    Getter method for configs, mapped from YANG variable /testbed/apps/pplb4s/configs (list)
    """
    return self.__configs
      
  def _set_configs(self, v, load=False):
    """
    Setter method for configs, mapped from YANG variable /testbed/apps/pplb4s/configs (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_configs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_configs() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_configs_sdn_testbed_spec__testbed_apps_pplb4s_configs, yang_name="configs", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="configs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """configs must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_configs_sdn_testbed_spec__testbed_apps_pplb4s_configs, yang_name="configs", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="configs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='list', is_config=True)""",
        })

    self.__configs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_configs(self):
    self.__configs = YANGDynClass(base=YANGListType("id",yc_configs_sdn_testbed_spec__testbed_apps_pplb4s_configs, yang_name="configs", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="configs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='list', is_config=True)

  targetSwitches = __builtin__.property(_get_targetSwitches, _set_targetSwitches)
  configs = __builtin__.property(_get_configs, _set_configs)


  _pyangbind_elements = OrderedDict([('targetSwitches', targetSwitches), ('configs', configs), ])


class yc_hostConfigs_sdn_testbed_spec__testbed_apps_hs_configs_hostConfigs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module sdn_testbed_spec - based on the path /testbed/apps/hs/configs/hostConfigs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__frontend','__backend',)

  _yang_name = 'hostConfigs'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__frontend = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'pc[0-9]{1,2}'}), is_leaf=True, yang_name="frontend", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='hostId', is_config=True)
    self.__backend = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'pc[0-9]{1,2}'}), is_leaf=True, yang_name="backend", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='hostId', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['testbed', 'apps', 'hs', 'configs', 'hostConfigs']

  def _get_frontend(self):
    """
    Getter method for frontend, mapped from YANG variable /testbed/apps/hs/configs/hostConfigs/frontend (hostId)
    """
    return self.__frontend
      
  def _set_frontend(self, v, load=False):
    """
    Setter method for frontend, mapped from YANG variable /testbed/apps/hs/configs/hostConfigs/frontend (hostId)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_frontend is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_frontend() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'pc[0-9]{1,2}'}), is_leaf=True, yang_name="frontend", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='hostId', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """frontend must be of a type compatible with hostId""",
          'defined-type': "sdn_testbed_spec:hostId",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'pc[0-9]{1,2}'}), is_leaf=True, yang_name="frontend", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='hostId', is_config=True)""",
        })

    self.__frontend = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_frontend(self):
    self.__frontend = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'pc[0-9]{1,2}'}), is_leaf=True, yang_name="frontend", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='hostId', is_config=True)


  def _get_backend(self):
    """
    Getter method for backend, mapped from YANG variable /testbed/apps/hs/configs/hostConfigs/backend (hostId)
    """
    return self.__backend
      
  def _set_backend(self, v, load=False):
    """
    Setter method for backend, mapped from YANG variable /testbed/apps/hs/configs/hostConfigs/backend (hostId)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_backend is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_backend() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'pc[0-9]{1,2}'}), is_leaf=True, yang_name="backend", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='hostId', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """backend must be of a type compatible with hostId""",
          'defined-type': "sdn_testbed_spec:hostId",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'pc[0-9]{1,2}'}), is_leaf=True, yang_name="backend", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='hostId', is_config=True)""",
        })

    self.__backend = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_backend(self):
    self.__backend = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'pc[0-9]{1,2}'}), is_leaf=True, yang_name="backend", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='hostId', is_config=True)

  frontend = __builtin__.property(_get_frontend, _set_frontend)
  backend = __builtin__.property(_get_backend, _set_backend)


  _pyangbind_elements = OrderedDict([('frontend', frontend), ('backend', backend), ])


class yc_configs_sdn_testbed_spec__testbed_apps_hs_configs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module sdn_testbed_spec - based on the path /testbed/apps/hs/configs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__hostConfigs',)

  _yang_name = 'configs'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='uint8', is_config=True)
    self.__hostConfigs = YANGDynClass(base=YANGListType("frontend",yc_hostConfigs_sdn_testbed_spec__testbed_apps_hs_configs_hostConfigs, yang_name="hostConfigs", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='frontend', extensions=None), is_container='list', yang_name="hostConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['testbed', 'apps', 'hs', 'configs']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /testbed/apps/hs/configs/id (uint8)
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /testbed/apps/hs/configs/id (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='uint8', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='uint8', is_config=True)


  def _get_hostConfigs(self):
    """
    Getter method for hostConfigs, mapped from YANG variable /testbed/apps/hs/configs/hostConfigs (list)
    """
    return self.__hostConfigs
      
  def _set_hostConfigs(self, v, load=False):
    """
    Setter method for hostConfigs, mapped from YANG variable /testbed/apps/hs/configs/hostConfigs (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hostConfigs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hostConfigs() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("frontend",yc_hostConfigs_sdn_testbed_spec__testbed_apps_hs_configs_hostConfigs, yang_name="hostConfigs", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='frontend', extensions=None), is_container='list', yang_name="hostConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hostConfigs must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("frontend",yc_hostConfigs_sdn_testbed_spec__testbed_apps_hs_configs_hostConfigs, yang_name="hostConfigs", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='frontend', extensions=None), is_container='list', yang_name="hostConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='list', is_config=True)""",
        })

    self.__hostConfigs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hostConfigs(self):
    self.__hostConfigs = YANGDynClass(base=YANGListType("frontend",yc_hostConfigs_sdn_testbed_spec__testbed_apps_hs_configs_hostConfigs, yang_name="hostConfigs", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='frontend', extensions=None), is_container='list', yang_name="hostConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='list', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  hostConfigs = __builtin__.property(_get_hostConfigs, _set_hostConfigs)


  _pyangbind_elements = OrderedDict([('id', id), ('hostConfigs', hostConfigs), ])


class yc_hs_sdn_testbed_spec__testbed_apps_hs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module sdn_testbed_spec - based on the path /testbed/apps/hs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__targetSwitches','__configs',)

  _yang_name = 'hs'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__targetSwitches = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}'})), is_leaf=False, yang_name="targetSwitches", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='switchId', is_config=True)
    self.__configs = YANGDynClass(base=YANGListType("id",yc_configs_sdn_testbed_spec__testbed_apps_hs_configs, yang_name="configs", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="configs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['testbed', 'apps', 'hs']

  def _get_targetSwitches(self):
    """
    Getter method for targetSwitches, mapped from YANG variable /testbed/apps/hs/targetSwitches (switchId)
    """
    return self.__targetSwitches
      
  def _set_targetSwitches(self, v, load=False):
    """
    Setter method for targetSwitches, mapped from YANG variable /testbed/apps/hs/targetSwitches (switchId)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_targetSwitches is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_targetSwitches() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}'})), is_leaf=False, yang_name="targetSwitches", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='switchId', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """targetSwitches must be of a type compatible with switchId""",
          'defined-type': "sdn_testbed_spec:switchId",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}'})), is_leaf=False, yang_name="targetSwitches", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='switchId', is_config=True)""",
        })

    self.__targetSwitches = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_targetSwitches(self):
    self.__targetSwitches = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}'})), is_leaf=False, yang_name="targetSwitches", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='switchId', is_config=True)


  def _get_configs(self):
    """
    Getter method for configs, mapped from YANG variable /testbed/apps/hs/configs (list)
    """
    return self.__configs
      
  def _set_configs(self, v, load=False):
    """
    Setter method for configs, mapped from YANG variable /testbed/apps/hs/configs (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_configs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_configs() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_configs_sdn_testbed_spec__testbed_apps_hs_configs, yang_name="configs", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="configs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """configs must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_configs_sdn_testbed_spec__testbed_apps_hs_configs, yang_name="configs", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="configs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='list', is_config=True)""",
        })

    self.__configs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_configs(self):
    self.__configs = YANGDynClass(base=YANGListType("id",yc_configs_sdn_testbed_spec__testbed_apps_hs_configs, yang_name="configs", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="configs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='list', is_config=True)

  targetSwitches = __builtin__.property(_get_targetSwitches, _set_targetSwitches)
  configs = __builtin__.property(_get_configs, _set_configs)


  _pyangbind_elements = OrderedDict([('targetSwitches', targetSwitches), ('configs', configs), ])


class yc_invariantsConfigs_sdn_testbed_spec__testbed_apps_pe_configs_invariantsConfigs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module sdn_testbed_spec - based on the path /testbed/apps/pe/configs/invariantsConfigs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__targetSwitch','__protos','__jumps',)

  _yang_name = 'invariantsConfigs'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__targetSwitch = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}'}), is_leaf=True, yang_name="targetSwitch", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='switchId', is_config=True)
    self.__protos = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'ip|tcp|udp'})), is_leaf=False, yang_name="protos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='proto', is_config=True)
    self.__jumps = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}'})), is_leaf=False, yang_name="jumps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='switchId', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['testbed', 'apps', 'pe', 'configs', 'invariantsConfigs']

  def _get_targetSwitch(self):
    """
    Getter method for targetSwitch, mapped from YANG variable /testbed/apps/pe/configs/invariantsConfigs/targetSwitch (switchId)
    """
    return self.__targetSwitch
      
  def _set_targetSwitch(self, v, load=False):
    """
    Setter method for targetSwitch, mapped from YANG variable /testbed/apps/pe/configs/invariantsConfigs/targetSwitch (switchId)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_targetSwitch is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_targetSwitch() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}'}), is_leaf=True, yang_name="targetSwitch", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='switchId', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """targetSwitch must be of a type compatible with switchId""",
          'defined-type': "sdn_testbed_spec:switchId",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}'}), is_leaf=True, yang_name="targetSwitch", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='switchId', is_config=True)""",
        })

    self.__targetSwitch = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_targetSwitch(self):
    self.__targetSwitch = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}'}), is_leaf=True, yang_name="targetSwitch", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='switchId', is_config=True)


  def _get_protos(self):
    """
    Getter method for protos, mapped from YANG variable /testbed/apps/pe/configs/invariantsConfigs/protos (proto)
    """
    return self.__protos
      
  def _set_protos(self, v, load=False):
    """
    Setter method for protos, mapped from YANG variable /testbed/apps/pe/configs/invariantsConfigs/protos (proto)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_protos is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_protos() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'ip|tcp|udp'})), is_leaf=False, yang_name="protos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='proto', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """protos must be of a type compatible with proto""",
          'defined-type': "sdn_testbed_spec:proto",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'ip|tcp|udp'})), is_leaf=False, yang_name="protos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='proto', is_config=True)""",
        })

    self.__protos = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_protos(self):
    self.__protos = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'ip|tcp|udp'})), is_leaf=False, yang_name="protos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='proto', is_config=True)


  def _get_jumps(self):
    """
    Getter method for jumps, mapped from YANG variable /testbed/apps/pe/configs/invariantsConfigs/jumps (switchId)
    """
    return self.__jumps
      
  def _set_jumps(self, v, load=False):
    """
    Setter method for jumps, mapped from YANG variable /testbed/apps/pe/configs/invariantsConfigs/jumps (switchId)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_jumps is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_jumps() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}'})), is_leaf=False, yang_name="jumps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='switchId', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """jumps must be of a type compatible with switchId""",
          'defined-type': "sdn_testbed_spec:switchId",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}'})), is_leaf=False, yang_name="jumps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='switchId', is_config=True)""",
        })

    self.__jumps = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_jumps(self):
    self.__jumps = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}'})), is_leaf=False, yang_name="jumps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='switchId', is_config=True)

  targetSwitch = __builtin__.property(_get_targetSwitch, _set_targetSwitch)
  protos = __builtin__.property(_get_protos, _set_protos)
  jumps = __builtin__.property(_get_jumps, _set_jumps)


  _pyangbind_elements = OrderedDict([('targetSwitch', targetSwitch), ('protos', protos), ('jumps', jumps), ])


class yc_configs_sdn_testbed_spec__testbed_apps_pe_configs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module sdn_testbed_spec - based on the path /testbed/apps/pe/configs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__invariantsConfigs',)

  _yang_name = 'configs'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='uint8', is_config=True)
    self.__invariantsConfigs = YANGDynClass(base=YANGListType("targetSwitch",yc_invariantsConfigs_sdn_testbed_spec__testbed_apps_pe_configs_invariantsConfigs, yang_name="invariantsConfigs", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='targetSwitch', extensions=None), is_container='list', yang_name="invariantsConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['testbed', 'apps', 'pe', 'configs']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /testbed/apps/pe/configs/id (uint8)
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /testbed/apps/pe/configs/id (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='uint8', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='uint8', is_config=True)


  def _get_invariantsConfigs(self):
    """
    Getter method for invariantsConfigs, mapped from YANG variable /testbed/apps/pe/configs/invariantsConfigs (list)
    """
    return self.__invariantsConfigs
      
  def _set_invariantsConfigs(self, v, load=False):
    """
    Setter method for invariantsConfigs, mapped from YANG variable /testbed/apps/pe/configs/invariantsConfigs (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_invariantsConfigs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_invariantsConfigs() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("targetSwitch",yc_invariantsConfigs_sdn_testbed_spec__testbed_apps_pe_configs_invariantsConfigs, yang_name="invariantsConfigs", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='targetSwitch', extensions=None), is_container='list', yang_name="invariantsConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """invariantsConfigs must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("targetSwitch",yc_invariantsConfigs_sdn_testbed_spec__testbed_apps_pe_configs_invariantsConfigs, yang_name="invariantsConfigs", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='targetSwitch', extensions=None), is_container='list', yang_name="invariantsConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='list', is_config=True)""",
        })

    self.__invariantsConfigs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_invariantsConfigs(self):
    self.__invariantsConfigs = YANGDynClass(base=YANGListType("targetSwitch",yc_invariantsConfigs_sdn_testbed_spec__testbed_apps_pe_configs_invariantsConfigs, yang_name="invariantsConfigs", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='targetSwitch', extensions=None), is_container='list', yang_name="invariantsConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='list', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  invariantsConfigs = __builtin__.property(_get_invariantsConfigs, _set_invariantsConfigs)


  _pyangbind_elements = OrderedDict([('id', id), ('invariantsConfigs', invariantsConfigs), ])


class yc_pe_sdn_testbed_spec__testbed_apps_pe(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module sdn_testbed_spec - based on the path /testbed/apps/pe. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__targetSwitches','__configs',)

  _yang_name = 'pe'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__targetSwitches = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}'})), is_leaf=False, yang_name="targetSwitches", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='switchId', is_config=True)
    self.__configs = YANGDynClass(base=YANGListType("id",yc_configs_sdn_testbed_spec__testbed_apps_pe_configs, yang_name="configs", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="configs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['testbed', 'apps', 'pe']

  def _get_targetSwitches(self):
    """
    Getter method for targetSwitches, mapped from YANG variable /testbed/apps/pe/targetSwitches (switchId)
    """
    return self.__targetSwitches
      
  def _set_targetSwitches(self, v, load=False):
    """
    Setter method for targetSwitches, mapped from YANG variable /testbed/apps/pe/targetSwitches (switchId)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_targetSwitches is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_targetSwitches() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}'})), is_leaf=False, yang_name="targetSwitches", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='switchId', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """targetSwitches must be of a type compatible with switchId""",
          'defined-type': "sdn_testbed_spec:switchId",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}'})), is_leaf=False, yang_name="targetSwitches", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='switchId', is_config=True)""",
        })

    self.__targetSwitches = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_targetSwitches(self):
    self.__targetSwitches = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}'})), is_leaf=False, yang_name="targetSwitches", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='switchId', is_config=True)


  def _get_configs(self):
    """
    Getter method for configs, mapped from YANG variable /testbed/apps/pe/configs (list)
    """
    return self.__configs
      
  def _set_configs(self, v, load=False):
    """
    Setter method for configs, mapped from YANG variable /testbed/apps/pe/configs (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_configs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_configs() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_configs_sdn_testbed_spec__testbed_apps_pe_configs, yang_name="configs", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="configs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """configs must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_configs_sdn_testbed_spec__testbed_apps_pe_configs, yang_name="configs", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="configs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='list', is_config=True)""",
        })

    self.__configs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_configs(self):
    self.__configs = YANGDynClass(base=YANGListType("id",yc_configs_sdn_testbed_spec__testbed_apps_pe_configs, yang_name="configs", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="configs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='list', is_config=True)

  targetSwitches = __builtin__.property(_get_targetSwitches, _set_targetSwitches)
  configs = __builtin__.property(_get_configs, _set_configs)


  _pyangbind_elements = OrderedDict([('targetSwitches', targetSwitches), ('configs', configs), ])


class yc_apps_sdn_testbed_spec__testbed_apps(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module sdn_testbed_spec - based on the path /testbed/apps. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of unique apps and their configurations. All app types that are defined for a switch must be specified once with a given number of configurations.
  """
  __slots__ = ('_path_helper', '_extmethods', '__eplb','__plb','__fw','__pplb4d','__pplb4s','__hs','__pe',)

  _yang_name = 'apps'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__eplb = YANGDynClass(base=yc_eplb_sdn_testbed_spec__testbed_apps_eplb, is_container='container', yang_name="eplb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='container', is_config=True)
    self.__plb = YANGDynClass(base=yc_plb_sdn_testbed_spec__testbed_apps_plb, is_container='container', yang_name="plb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='container', is_config=True)
    self.__fw = YANGDynClass(base=yc_fw_sdn_testbed_spec__testbed_apps_fw, is_container='container', yang_name="fw", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='container', is_config=True)
    self.__pplb4d = YANGDynClass(base=yc_pplb4d_sdn_testbed_spec__testbed_apps_pplb4d, is_container='container', yang_name="pplb4d", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='container', is_config=True)
    self.__pplb4s = YANGDynClass(base=yc_pplb4s_sdn_testbed_spec__testbed_apps_pplb4s, is_container='container', yang_name="pplb4s", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='container', is_config=True)
    self.__hs = YANGDynClass(base=yc_hs_sdn_testbed_spec__testbed_apps_hs, is_container='container', yang_name="hs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='container', is_config=True)
    self.__pe = YANGDynClass(base=yc_pe_sdn_testbed_spec__testbed_apps_pe, is_container='container', yang_name="pe", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['testbed', 'apps']

  def _get_eplb(self):
    """
    Getter method for eplb, mapped from YANG variable /testbed/apps/eplb (container)
    """
    return self.__eplb
      
  def _set_eplb(self, v, load=False):
    """
    Setter method for eplb, mapped from YANG variable /testbed/apps/eplb (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_eplb is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_eplb() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_eplb_sdn_testbed_spec__testbed_apps_eplb, is_container='container', yang_name="eplb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """eplb must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_eplb_sdn_testbed_spec__testbed_apps_eplb, is_container='container', yang_name="eplb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='container', is_config=True)""",
        })

    self.__eplb = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_eplb(self):
    self.__eplb = YANGDynClass(base=yc_eplb_sdn_testbed_spec__testbed_apps_eplb, is_container='container', yang_name="eplb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='container', is_config=True)


  def _get_plb(self):
    """
    Getter method for plb, mapped from YANG variable /testbed/apps/plb (container)
    """
    return self.__plb
      
  def _set_plb(self, v, load=False):
    """
    Setter method for plb, mapped from YANG variable /testbed/apps/plb (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_plb is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_plb() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_plb_sdn_testbed_spec__testbed_apps_plb, is_container='container', yang_name="plb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """plb must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_plb_sdn_testbed_spec__testbed_apps_plb, is_container='container', yang_name="plb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='container', is_config=True)""",
        })

    self.__plb = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_plb(self):
    self.__plb = YANGDynClass(base=yc_plb_sdn_testbed_spec__testbed_apps_plb, is_container='container', yang_name="plb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='container', is_config=True)


  def _get_fw(self):
    """
    Getter method for fw, mapped from YANG variable /testbed/apps/fw (container)
    """
    return self.__fw
      
  def _set_fw(self, v, load=False):
    """
    Setter method for fw, mapped from YANG variable /testbed/apps/fw (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fw is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fw() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_fw_sdn_testbed_spec__testbed_apps_fw, is_container='container', yang_name="fw", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fw must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_fw_sdn_testbed_spec__testbed_apps_fw, is_container='container', yang_name="fw", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='container', is_config=True)""",
        })

    self.__fw = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fw(self):
    self.__fw = YANGDynClass(base=yc_fw_sdn_testbed_spec__testbed_apps_fw, is_container='container', yang_name="fw", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='container', is_config=True)


  def _get_pplb4d(self):
    """
    Getter method for pplb4d, mapped from YANG variable /testbed/apps/pplb4d (container)
    """
    return self.__pplb4d
      
  def _set_pplb4d(self, v, load=False):
    """
    Setter method for pplb4d, mapped from YANG variable /testbed/apps/pplb4d (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pplb4d is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pplb4d() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_pplb4d_sdn_testbed_spec__testbed_apps_pplb4d, is_container='container', yang_name="pplb4d", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """pplb4d must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_pplb4d_sdn_testbed_spec__testbed_apps_pplb4d, is_container='container', yang_name="pplb4d", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='container', is_config=True)""",
        })

    self.__pplb4d = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_pplb4d(self):
    self.__pplb4d = YANGDynClass(base=yc_pplb4d_sdn_testbed_spec__testbed_apps_pplb4d, is_container='container', yang_name="pplb4d", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='container', is_config=True)


  def _get_pplb4s(self):
    """
    Getter method for pplb4s, mapped from YANG variable /testbed/apps/pplb4s (container)
    """
    return self.__pplb4s
      
  def _set_pplb4s(self, v, load=False):
    """
    Setter method for pplb4s, mapped from YANG variable /testbed/apps/pplb4s (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pplb4s is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pplb4s() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_pplb4s_sdn_testbed_spec__testbed_apps_pplb4s, is_container='container', yang_name="pplb4s", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """pplb4s must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_pplb4s_sdn_testbed_spec__testbed_apps_pplb4s, is_container='container', yang_name="pplb4s", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='container', is_config=True)""",
        })

    self.__pplb4s = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_pplb4s(self):
    self.__pplb4s = YANGDynClass(base=yc_pplb4s_sdn_testbed_spec__testbed_apps_pplb4s, is_container='container', yang_name="pplb4s", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='container', is_config=True)


  def _get_hs(self):
    """
    Getter method for hs, mapped from YANG variable /testbed/apps/hs (container)
    """
    return self.__hs
      
  def _set_hs(self, v, load=False):
    """
    Setter method for hs, mapped from YANG variable /testbed/apps/hs (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hs() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_hs_sdn_testbed_spec__testbed_apps_hs, is_container='container', yang_name="hs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hs must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_hs_sdn_testbed_spec__testbed_apps_hs, is_container='container', yang_name="hs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='container', is_config=True)""",
        })

    self.__hs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hs(self):
    self.__hs = YANGDynClass(base=yc_hs_sdn_testbed_spec__testbed_apps_hs, is_container='container', yang_name="hs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='container', is_config=True)


  def _get_pe(self):
    """
    Getter method for pe, mapped from YANG variable /testbed/apps/pe (container)
    """
    return self.__pe
      
  def _set_pe(self, v, load=False):
    """
    Setter method for pe, mapped from YANG variable /testbed/apps/pe (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pe is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pe() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_pe_sdn_testbed_spec__testbed_apps_pe, is_container='container', yang_name="pe", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """pe must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_pe_sdn_testbed_spec__testbed_apps_pe, is_container='container', yang_name="pe", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='container', is_config=True)""",
        })

    self.__pe = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_pe(self):
    self.__pe = YANGDynClass(base=yc_pe_sdn_testbed_spec__testbed_apps_pe, is_container='container', yang_name="pe", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='container', is_config=True)

  eplb = __builtin__.property(_get_eplb, _set_eplb)
  plb = __builtin__.property(_get_plb, _set_plb)
  fw = __builtin__.property(_get_fw, _set_fw)
  pplb4d = __builtin__.property(_get_pplb4d, _set_pplb4d)
  pplb4s = __builtin__.property(_get_pplb4s, _set_pplb4s)
  hs = __builtin__.property(_get_hs, _set_hs)
  pe = __builtin__.property(_get_pe, _set_pe)


  _pyangbind_elements = OrderedDict([('eplb', eplb), ('plb', plb), ('fw', fw), ('pplb4d', pplb4d), ('pplb4s', pplb4s), ('hs', hs), ('pe', pe), ])


class yc_switches_sdn_testbed_spec__testbed_switches(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module sdn_testbed_spec - based on the path /testbed/switches. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of unique switches in the testbed.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id',)

  _yang_name = 'switches'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}'}), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='switchId', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['testbed', 'switches']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /testbed/switches/id (switchId)
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /testbed/switches/id (switchId)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}'}), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='switchId', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with switchId""",
          'defined-type': "sdn_testbed_spec:switchId",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}'}), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='switchId', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}'}), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='switchId', is_config=True)

  id = __builtin__.property(_get_id, _set_id)


  _pyangbind_elements = OrderedDict([('id', id), ])


class yc_hosts_sdn_testbed_spec__testbed_hosts(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module sdn_testbed_spec - based on the path /testbed/hosts. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of host nodes in the topology. The source attribute specifies wheather a host will be used as a source for network traffic in a test configuration. Default is false, so host will be a sink.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__source',)

  _yang_name = 'hosts'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'pc[0-9]{1,2}'}), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='hostId', is_config=True)
    self.__source = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['testbed', 'hosts']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /testbed/hosts/id (hostId)
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /testbed/hosts/id (hostId)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'pc[0-9]{1,2}'}), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='hostId', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with hostId""",
          'defined-type': "sdn_testbed_spec:hostId",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'pc[0-9]{1,2}'}), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='hostId', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'pc[0-9]{1,2}'}), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='hostId', is_config=True)


  def _get_source(self):
    """
    Getter method for source, mapped from YANG variable /testbed/hosts/source (boolean)
    """
    return self.__source
      
  def _set_source(self, v, load=False):
    """
    Setter method for source, mapped from YANG variable /testbed/hosts/source (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='boolean', is_config=True)""",
        })

    self.__source = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source(self):
    self.__source = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='boolean', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  source = __builtin__.property(_get_source, _set_source)


  _pyangbind_elements = OrderedDict([('id', id), ('source', source), ])


class yc_edges_sdn_testbed_spec__testbed_edges(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module sdn_testbed_spec - based on the path /testbed/edges. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__nodes',)

  _yang_name = 'edges'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='uint8', is_config=True)
    self.__nodes = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}|pc[0-9]{1,2}'})), is_leaf=False, yang_name="nodes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='nodeId', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['testbed', 'edges']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /testbed/edges/id (uint8)
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /testbed/edges/id (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='uint8', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='uint8', is_config=True)


  def _get_nodes(self):
    """
    Getter method for nodes, mapped from YANG variable /testbed/edges/nodes (nodeId)
    """
    return self.__nodes
      
  def _set_nodes(self, v, load=False):
    """
    Setter method for nodes, mapped from YANG variable /testbed/edges/nodes (nodeId)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nodes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nodes() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}|pc[0-9]{1,2}'})), is_leaf=False, yang_name="nodes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='nodeId', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nodes must be of a type compatible with nodeId""",
          'defined-type': "sdn_testbed_spec:nodeId",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}|pc[0-9]{1,2}'})), is_leaf=False, yang_name="nodes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='nodeId', is_config=True)""",
        })

    self.__nodes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nodes(self):
    self.__nodes = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}|pc[0-9]{1,2}'})), is_leaf=False, yang_name="nodes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='nodeId', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  nodes = __builtin__.property(_get_nodes, _set_nodes)


  _pyangbind_elements = OrderedDict([('id', id), ('nodes', nodes), ])


class yc_testbed_sdn_testbed_spec__testbed(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module sdn_testbed_spec - based on the path /testbed. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__topologyId','__autostart','__apps','__trafficProfiles','__trafficTypes','__switches','__hosts','__edges',)

  _yang_name = 'testbed'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__topologyId = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="topologyId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='string', is_config=True)
    self.__autostart = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="autostart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='boolean', is_config=True)
    self.__apps = YANGDynClass(base=yc_apps_sdn_testbed_spec__testbed_apps, is_container='container', yang_name="apps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='container', is_config=True)
    self.__trafficProfiles = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'cbr': {}, 'vbr': {}, 'bursty': {}},)), is_leaf=False, yang_name="trafficProfiles", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='trafficProfile', is_config=True)
    self.__trafficTypes = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'tcp': {}, 'udp': {}},)), is_leaf=False, yang_name="trafficTypes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='trafficType', is_config=True)
    self.__switches = YANGDynClass(base=YANGListType("id",yc_switches_sdn_testbed_spec__testbed_switches, yang_name="switches", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="switches", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='list', is_config=True)
    self.__hosts = YANGDynClass(base=YANGListType("id",yc_hosts_sdn_testbed_spec__testbed_hosts, yang_name="hosts", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="hosts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='list', is_config=True)
    self.__edges = YANGDynClass(base=YANGListType("id",yc_edges_sdn_testbed_spec__testbed_edges, yang_name="edges", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="edges", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['testbed']

  def _get_topologyId(self):
    """
    Getter method for topologyId, mapped from YANG variable /testbed/topologyId (string)

    YANG Description: Unique identifer for the topology.
    """
    return self.__topologyId
      
  def _set_topologyId(self, v, load=False):
    """
    Setter method for topologyId, mapped from YANG variable /testbed/topologyId (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_topologyId is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_topologyId() directly.

    YANG Description: Unique identifer for the topology.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="topologyId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """topologyId must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="topologyId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='string', is_config=True)""",
        })

    self.__topologyId = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_topologyId(self):
    self.__topologyId = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="topologyId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='string', is_config=True)


  def _get_autostart(self):
    """
    Getter method for autostart, mapped from YANG variable /testbed/autostart (boolean)
    """
    return self.__autostart
      
  def _set_autostart(self, v, load=False):
    """
    Setter method for autostart, mapped from YANG variable /testbed/autostart (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_autostart is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_autostart() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="autostart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """autostart must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="autostart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='boolean', is_config=True)""",
        })

    self.__autostart = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_autostart(self):
    self.__autostart = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="autostart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='boolean', is_config=True)


  def _get_apps(self):
    """
    Getter method for apps, mapped from YANG variable /testbed/apps (container)

    YANG Description: List of unique apps and their configurations. All app types that are defined for a switch must be specified once with a given number of configurations.
    """
    return self.__apps
      
  def _set_apps(self, v, load=False):
    """
    Setter method for apps, mapped from YANG variable /testbed/apps (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_apps is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_apps() directly.

    YANG Description: List of unique apps and their configurations. All app types that are defined for a switch must be specified once with a given number of configurations.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_apps_sdn_testbed_spec__testbed_apps, is_container='container', yang_name="apps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """apps must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_apps_sdn_testbed_spec__testbed_apps, is_container='container', yang_name="apps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='container', is_config=True)""",
        })

    self.__apps = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_apps(self):
    self.__apps = YANGDynClass(base=yc_apps_sdn_testbed_spec__testbed_apps, is_container='container', yang_name="apps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='container', is_config=True)


  def _get_trafficProfiles(self):
    """
    Getter method for trafficProfiles, mapped from YANG variable /testbed/trafficProfiles (trafficProfile)

    YANG Description: Traffic profile can be cbr, vbr or bursty
    """
    return self.__trafficProfiles
      
  def _set_trafficProfiles(self, v, load=False):
    """
    Setter method for trafficProfiles, mapped from YANG variable /testbed/trafficProfiles (trafficProfile)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_trafficProfiles is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_trafficProfiles() directly.

    YANG Description: Traffic profile can be cbr, vbr or bursty
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'cbr': {}, 'vbr': {}, 'bursty': {}},)), is_leaf=False, yang_name="trafficProfiles", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='trafficProfile', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """trafficProfiles must be of a type compatible with trafficProfile""",
          'defined-type': "sdn_testbed_spec:trafficProfile",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'cbr': {}, 'vbr': {}, 'bursty': {}},)), is_leaf=False, yang_name="trafficProfiles", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='trafficProfile', is_config=True)""",
        })

    self.__trafficProfiles = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_trafficProfiles(self):
    self.__trafficProfiles = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'cbr': {}, 'vbr': {}, 'bursty': {}},)), is_leaf=False, yang_name="trafficProfiles", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='trafficProfile', is_config=True)


  def _get_trafficTypes(self):
    """
    Getter method for trafficTypes, mapped from YANG variable /testbed/trafficTypes (trafficType)

    YANG Description: Traffic type can be tcp or udp
    """
    return self.__trafficTypes
      
  def _set_trafficTypes(self, v, load=False):
    """
    Setter method for trafficTypes, mapped from YANG variable /testbed/trafficTypes (trafficType)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_trafficTypes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_trafficTypes() directly.

    YANG Description: Traffic type can be tcp or udp
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'tcp': {}, 'udp': {}},)), is_leaf=False, yang_name="trafficTypes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='trafficType', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """trafficTypes must be of a type compatible with trafficType""",
          'defined-type': "sdn_testbed_spec:trafficType",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'tcp': {}, 'udp': {}},)), is_leaf=False, yang_name="trafficTypes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='trafficType', is_config=True)""",
        })

    self.__trafficTypes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_trafficTypes(self):
    self.__trafficTypes = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'tcp': {}, 'udp': {}},)), is_leaf=False, yang_name="trafficTypes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='trafficType', is_config=True)


  def _get_switches(self):
    """
    Getter method for switches, mapped from YANG variable /testbed/switches (list)

    YANG Description: List of unique switches in the testbed.
    """
    return self.__switches
      
  def _set_switches(self, v, load=False):
    """
    Setter method for switches, mapped from YANG variable /testbed/switches (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_switches is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_switches() directly.

    YANG Description: List of unique switches in the testbed.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_switches_sdn_testbed_spec__testbed_switches, yang_name="switches", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="switches", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """switches must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_switches_sdn_testbed_spec__testbed_switches, yang_name="switches", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="switches", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='list', is_config=True)""",
        })

    self.__switches = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_switches(self):
    self.__switches = YANGDynClass(base=YANGListType("id",yc_switches_sdn_testbed_spec__testbed_switches, yang_name="switches", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="switches", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='list', is_config=True)


  def _get_hosts(self):
    """
    Getter method for hosts, mapped from YANG variable /testbed/hosts (list)

    YANG Description: List of host nodes in the topology. The source attribute specifies wheather a host will be used as a source for network traffic in a test configuration. Default is false, so host will be a sink.
    """
    return self.__hosts
      
  def _set_hosts(self, v, load=False):
    """
    Setter method for hosts, mapped from YANG variable /testbed/hosts (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hosts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hosts() directly.

    YANG Description: List of host nodes in the topology. The source attribute specifies wheather a host will be used as a source for network traffic in a test configuration. Default is false, so host will be a sink.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_hosts_sdn_testbed_spec__testbed_hosts, yang_name="hosts", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="hosts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hosts must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_hosts_sdn_testbed_spec__testbed_hosts, yang_name="hosts", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="hosts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='list', is_config=True)""",
        })

    self.__hosts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hosts(self):
    self.__hosts = YANGDynClass(base=YANGListType("id",yc_hosts_sdn_testbed_spec__testbed_hosts, yang_name="hosts", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="hosts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='list', is_config=True)


  def _get_edges(self):
    """
    Getter method for edges, mapped from YANG variable /testbed/edges (list)
    """
    return self.__edges
      
  def _set_edges(self, v, load=False):
    """
    Setter method for edges, mapped from YANG variable /testbed/edges (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_edges is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_edges() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_edges_sdn_testbed_spec__testbed_edges, yang_name="edges", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="edges", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """edges must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_edges_sdn_testbed_spec__testbed_edges, yang_name="edges", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="edges", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='list', is_config=True)""",
        })

    self.__edges = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_edges(self):
    self.__edges = YANGDynClass(base=YANGListType("id",yc_edges_sdn_testbed_spec__testbed_edges, yang_name="edges", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="edges", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='list', is_config=True)

  topologyId = __builtin__.property(_get_topologyId, _set_topologyId)
  autostart = __builtin__.property(_get_autostart, _set_autostart)
  apps = __builtin__.property(_get_apps, _set_apps)
  trafficProfiles = __builtin__.property(_get_trafficProfiles, _set_trafficProfiles)
  trafficTypes = __builtin__.property(_get_trafficTypes, _set_trafficTypes)
  switches = __builtin__.property(_get_switches, _set_switches)
  hosts = __builtin__.property(_get_hosts, _set_hosts)
  edges = __builtin__.property(_get_edges, _set_edges)


  _pyangbind_elements = OrderedDict([('topologyId', topologyId), ('autostart', autostart), ('apps', apps), ('trafficProfiles', trafficProfiles), ('trafficTypes', trafficTypes), ('switches', switches), ('hosts', hosts), ('edges', edges), ])


class sdn_testbed_spec(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module sdn_testbed_spec - based on the path /sdn_testbed_spec. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__testbed',)

  _yang_name = 'sdn_testbed_spec'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__testbed = YANGDynClass(base=yc_testbed_sdn_testbed_spec__testbed, is_container='container', yang_name="testbed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_testbed(self):
    """
    Getter method for testbed, mapped from YANG variable /testbed (container)
    """
    return self.__testbed
      
  def _set_testbed(self, v, load=False):
    """
    Setter method for testbed, mapped from YANG variable /testbed (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_testbed is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_testbed() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_testbed_sdn_testbed_spec__testbed, is_container='container', yang_name="testbed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """testbed must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_testbed_sdn_testbed_spec__testbed, is_container='container', yang_name="testbed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='container', is_config=True)""",
        })

    self.__testbed = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_testbed(self):
    self.__testbed = YANGDynClass(base=yc_testbed_sdn_testbed_spec__testbed, is_container='container', yang_name="testbed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec', yang_type='container', is_config=True)

  testbed = __builtin__.property(_get_testbed, _set_testbed)


  _pyangbind_elements = OrderedDict([('testbed', testbed), ])


