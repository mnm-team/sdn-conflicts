# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

class yc_appInvariants_sdn_testbed_spec_v2__testbed_apps_config_appInvariants(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module sdn_testbed_spec_v2 - based on the path /testbed/apps/config/appInvariants. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: An app can have invariants as config which will be transfered as json dict to the config file. See invariants for details.
  """
  __slots__ = ('_path_helper', '_extmethods', '__invariantKey','__intValue','__stringValue','__intItems','__stringItems',)

  _yang_name = 'appInvariants'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__invariantKey = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="invariantKey", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='string', is_config=True)
    self.__intValue = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="intValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='int8', is_config=True)
    self.__stringValue = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="stringValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='string', is_config=True)
    self.__intItems = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8)), is_leaf=False, yang_name="intItems", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='int8', is_config=True)
    self.__stringItems = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="stringItems", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['testbed', 'apps', 'config', 'appInvariants']

  def _get_invariantKey(self):
    """
    Getter method for invariantKey, mapped from YANG variable /testbed/apps/config/appInvariants/invariantKey (string)
    """
    return self.__invariantKey
      
  def _set_invariantKey(self, v, load=False):
    """
    Setter method for invariantKey, mapped from YANG variable /testbed/apps/config/appInvariants/invariantKey (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_invariantKey is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_invariantKey() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="invariantKey", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """invariantKey must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="invariantKey", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='string', is_config=True)""",
        })

    self.__invariantKey = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_invariantKey(self):
    self.__invariantKey = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="invariantKey", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='string', is_config=True)


  def _get_intValue(self):
    """
    Getter method for intValue, mapped from YANG variable /testbed/apps/config/appInvariants/intValue (int8)
    """
    return self.__intValue
      
  def _set_intValue(self, v, load=False):
    """
    Setter method for intValue, mapped from YANG variable /testbed/apps/config/appInvariants/intValue (int8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_intValue is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_intValue() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="intValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='int8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """intValue must be of a type compatible with int8""",
          'defined-type': "int8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="intValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='int8', is_config=True)""",
        })

    self.__intValue = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_intValue(self):
    self.__intValue = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="intValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='int8', is_config=True)


  def _get_stringValue(self):
    """
    Getter method for stringValue, mapped from YANG variable /testbed/apps/config/appInvariants/stringValue (string)
    """
    return self.__stringValue
      
  def _set_stringValue(self, v, load=False):
    """
    Setter method for stringValue, mapped from YANG variable /testbed/apps/config/appInvariants/stringValue (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_stringValue is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_stringValue() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="stringValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """stringValue must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="stringValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='string', is_config=True)""",
        })

    self.__stringValue = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_stringValue(self):
    self.__stringValue = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="stringValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='string', is_config=True)


  def _get_intItems(self):
    """
    Getter method for intItems, mapped from YANG variable /testbed/apps/config/appInvariants/intItems (int8)
    """
    return self.__intItems
      
  def _set_intItems(self, v, load=False):
    """
    Setter method for intItems, mapped from YANG variable /testbed/apps/config/appInvariants/intItems (int8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_intItems is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_intItems() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8)), is_leaf=False, yang_name="intItems", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='int8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """intItems must be of a type compatible with int8""",
          'defined-type': "int8",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8)), is_leaf=False, yang_name="intItems", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='int8', is_config=True)""",
        })

    self.__intItems = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_intItems(self):
    self.__intItems = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8)), is_leaf=False, yang_name="intItems", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='int8', is_config=True)


  def _get_stringItems(self):
    """
    Getter method for stringItems, mapped from YANG variable /testbed/apps/config/appInvariants/stringItems (string)
    """
    return self.__stringItems
      
  def _set_stringItems(self, v, load=False):
    """
    Setter method for stringItems, mapped from YANG variable /testbed/apps/config/appInvariants/stringItems (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_stringItems is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_stringItems() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="stringItems", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """stringItems must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="stringItems", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='string', is_config=True)""",
        })

    self.__stringItems = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_stringItems(self):
    self.__stringItems = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="stringItems", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='string', is_config=True)

  invariantKey = __builtin__.property(_get_invariantKey, _set_invariantKey)
  intValue = __builtin__.property(_get_intValue, _set_intValue)
  stringValue = __builtin__.property(_get_stringValue, _set_stringValue)
  intItems = __builtin__.property(_get_intItems, _set_intItems)
  stringItems = __builtin__.property(_get_stringItems, _set_stringItems)


  _pyangbind_elements = OrderedDict([('invariantKey', invariantKey), ('intValue', intValue), ('stringValue', stringValue), ('intItems', intItems), ('stringItems', stringItems), ])


class yc_switchInvariants_sdn_testbed_spec_v2__testbed_apps_config_targetSwitches_switchInvariants(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module sdn_testbed_spec_v2 - based on the path /testbed/apps/config/targetSwitches/switchInvariants. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__invariantKey','__intValue','__stringValue','__intItems','__stringItems',)

  _yang_name = 'switchInvariants'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__invariantKey = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="invariantKey", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='string', is_config=True)
    self.__intValue = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="intValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='int8', is_config=True)
    self.__stringValue = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="stringValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='string', is_config=True)
    self.__intItems = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8)), is_leaf=False, yang_name="intItems", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='int8', is_config=True)
    self.__stringItems = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="stringItems", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['testbed', 'apps', 'config', 'targetSwitches', 'switchInvariants']

  def _get_invariantKey(self):
    """
    Getter method for invariantKey, mapped from YANG variable /testbed/apps/config/targetSwitches/switchInvariants/invariantKey (string)
    """
    return self.__invariantKey
      
  def _set_invariantKey(self, v, load=False):
    """
    Setter method for invariantKey, mapped from YANG variable /testbed/apps/config/targetSwitches/switchInvariants/invariantKey (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_invariantKey is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_invariantKey() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="invariantKey", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """invariantKey must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="invariantKey", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='string', is_config=True)""",
        })

    self.__invariantKey = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_invariantKey(self):
    self.__invariantKey = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="invariantKey", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='string', is_config=True)


  def _get_intValue(self):
    """
    Getter method for intValue, mapped from YANG variable /testbed/apps/config/targetSwitches/switchInvariants/intValue (int8)
    """
    return self.__intValue
      
  def _set_intValue(self, v, load=False):
    """
    Setter method for intValue, mapped from YANG variable /testbed/apps/config/targetSwitches/switchInvariants/intValue (int8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_intValue is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_intValue() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="intValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='int8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """intValue must be of a type compatible with int8""",
          'defined-type': "int8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="intValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='int8', is_config=True)""",
        })

    self.__intValue = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_intValue(self):
    self.__intValue = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="intValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='int8', is_config=True)


  def _get_stringValue(self):
    """
    Getter method for stringValue, mapped from YANG variable /testbed/apps/config/targetSwitches/switchInvariants/stringValue (string)
    """
    return self.__stringValue
      
  def _set_stringValue(self, v, load=False):
    """
    Setter method for stringValue, mapped from YANG variable /testbed/apps/config/targetSwitches/switchInvariants/stringValue (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_stringValue is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_stringValue() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="stringValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """stringValue must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="stringValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='string', is_config=True)""",
        })

    self.__stringValue = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_stringValue(self):
    self.__stringValue = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="stringValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='string', is_config=True)


  def _get_intItems(self):
    """
    Getter method for intItems, mapped from YANG variable /testbed/apps/config/targetSwitches/switchInvariants/intItems (int8)
    """
    return self.__intItems
      
  def _set_intItems(self, v, load=False):
    """
    Setter method for intItems, mapped from YANG variable /testbed/apps/config/targetSwitches/switchInvariants/intItems (int8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_intItems is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_intItems() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8)), is_leaf=False, yang_name="intItems", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='int8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """intItems must be of a type compatible with int8""",
          'defined-type': "int8",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8)), is_leaf=False, yang_name="intItems", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='int8', is_config=True)""",
        })

    self.__intItems = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_intItems(self):
    self.__intItems = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8)), is_leaf=False, yang_name="intItems", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='int8', is_config=True)


  def _get_stringItems(self):
    """
    Getter method for stringItems, mapped from YANG variable /testbed/apps/config/targetSwitches/switchInvariants/stringItems (string)
    """
    return self.__stringItems
      
  def _set_stringItems(self, v, load=False):
    """
    Setter method for stringItems, mapped from YANG variable /testbed/apps/config/targetSwitches/switchInvariants/stringItems (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_stringItems is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_stringItems() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="stringItems", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """stringItems must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="stringItems", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='string', is_config=True)""",
        })

    self.__stringItems = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_stringItems(self):
    self.__stringItems = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="stringItems", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='string', is_config=True)

  invariantKey = __builtin__.property(_get_invariantKey, _set_invariantKey)
  intValue = __builtin__.property(_get_intValue, _set_intValue)
  stringValue = __builtin__.property(_get_stringValue, _set_stringValue)
  intItems = __builtin__.property(_get_intItems, _set_intItems)
  stringItems = __builtin__.property(_get_stringItems, _set_stringItems)


  _pyangbind_elements = OrderedDict([('invariantKey', invariantKey), ('intValue', intValue), ('stringValue', stringValue), ('intItems', intItems), ('stringItems', stringItems), ])


class yc_majorAsset_sdn_testbed_spec_v2__testbed_apps_config_targetSwitches_switchAssets_majorAsset(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module sdn_testbed_spec_v2 - based on the path /testbed/apps/config/targetSwitches/switchAssets/majorAsset. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__assetKey','__assetValue',)

  _yang_name = 'majorAsset'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__assetKey = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="assetKey", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='string', is_config=True)
    self.__assetValue = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'pc[0-9]{1,2}'}), is_leaf=True, yang_name="assetValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='hostId', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['testbed', 'apps', 'config', 'targetSwitches', 'switchAssets', 'majorAsset']

  def _get_assetKey(self):
    """
    Getter method for assetKey, mapped from YANG variable /testbed/apps/config/targetSwitches/switchAssets/majorAsset/assetKey (string)
    """
    return self.__assetKey
      
  def _set_assetKey(self, v, load=False):
    """
    Setter method for assetKey, mapped from YANG variable /testbed/apps/config/targetSwitches/switchAssets/majorAsset/assetKey (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_assetKey is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_assetKey() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="assetKey", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """assetKey must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="assetKey", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='string', is_config=True)""",
        })

    self.__assetKey = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_assetKey(self):
    self.__assetKey = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="assetKey", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='string', is_config=True)


  def _get_assetValue(self):
    """
    Getter method for assetValue, mapped from YANG variable /testbed/apps/config/targetSwitches/switchAssets/majorAsset/assetValue (hostId)
    """
    return self.__assetValue
      
  def _set_assetValue(self, v, load=False):
    """
    Setter method for assetValue, mapped from YANG variable /testbed/apps/config/targetSwitches/switchAssets/majorAsset/assetValue (hostId)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_assetValue is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_assetValue() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'pc[0-9]{1,2}'}), is_leaf=True, yang_name="assetValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='hostId', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """assetValue must be of a type compatible with hostId""",
          'defined-type': "sdn_testbed_spec_v2:hostId",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'pc[0-9]{1,2}'}), is_leaf=True, yang_name="assetValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='hostId', is_config=True)""",
        })

    self.__assetValue = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_assetValue(self):
    self.__assetValue = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'pc[0-9]{1,2}'}), is_leaf=True, yang_name="assetValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='hostId', is_config=True)

  assetKey = __builtin__.property(_get_assetKey, _set_assetKey)
  assetValue = __builtin__.property(_get_assetValue, _set_assetValue)


  _pyangbind_elements = OrderedDict([('assetKey', assetKey), ('assetValue', assetValue), ])


class yc_minorAssets_sdn_testbed_spec_v2__testbed_apps_config_targetSwitches_switchAssets_minorAssets(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module sdn_testbed_spec_v2 - based on the path /testbed/apps/config/targetSwitches/switchAssets/minorAssets. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__assetKey','__assetValue','__assetItems',)

  _yang_name = 'minorAssets'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__assetKey = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="assetKey", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='string', is_config=True)
    self.__assetValue = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}|pc[0-9]{1,2}'}), is_leaf=True, yang_name="assetValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='nodeId', is_config=True)
    self.__assetItems = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}|pc[0-9]{1,2}'})), is_leaf=False, yang_name="assetItems", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='nodeId', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['testbed', 'apps', 'config', 'targetSwitches', 'switchAssets', 'minorAssets']

  def _get_assetKey(self):
    """
    Getter method for assetKey, mapped from YANG variable /testbed/apps/config/targetSwitches/switchAssets/minorAssets/assetKey (string)
    """
    return self.__assetKey
      
  def _set_assetKey(self, v, load=False):
    """
    Setter method for assetKey, mapped from YANG variable /testbed/apps/config/targetSwitches/switchAssets/minorAssets/assetKey (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_assetKey is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_assetKey() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="assetKey", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """assetKey must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="assetKey", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='string', is_config=True)""",
        })

    self.__assetKey = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_assetKey(self):
    self.__assetKey = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="assetKey", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='string', is_config=True)


  def _get_assetValue(self):
    """
    Getter method for assetValue, mapped from YANG variable /testbed/apps/config/targetSwitches/switchAssets/minorAssets/assetValue (nodeId)
    """
    return self.__assetValue
      
  def _set_assetValue(self, v, load=False):
    """
    Setter method for assetValue, mapped from YANG variable /testbed/apps/config/targetSwitches/switchAssets/minorAssets/assetValue (nodeId)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_assetValue is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_assetValue() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}|pc[0-9]{1,2}'}), is_leaf=True, yang_name="assetValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='nodeId', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """assetValue must be of a type compatible with nodeId""",
          'defined-type': "sdn_testbed_spec_v2:nodeId",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}|pc[0-9]{1,2}'}), is_leaf=True, yang_name="assetValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='nodeId', is_config=True)""",
        })

    self.__assetValue = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_assetValue(self):
    self.__assetValue = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}|pc[0-9]{1,2}'}), is_leaf=True, yang_name="assetValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='nodeId', is_config=True)


  def _get_assetItems(self):
    """
    Getter method for assetItems, mapped from YANG variable /testbed/apps/config/targetSwitches/switchAssets/minorAssets/assetItems (nodeId)
    """
    return self.__assetItems
      
  def _set_assetItems(self, v, load=False):
    """
    Setter method for assetItems, mapped from YANG variable /testbed/apps/config/targetSwitches/switchAssets/minorAssets/assetItems (nodeId)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_assetItems is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_assetItems() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}|pc[0-9]{1,2}'})), is_leaf=False, yang_name="assetItems", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='nodeId', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """assetItems must be of a type compatible with nodeId""",
          'defined-type': "sdn_testbed_spec_v2:nodeId",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}|pc[0-9]{1,2}'})), is_leaf=False, yang_name="assetItems", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='nodeId', is_config=True)""",
        })

    self.__assetItems = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_assetItems(self):
    self.__assetItems = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}|pc[0-9]{1,2}'})), is_leaf=False, yang_name="assetItems", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='nodeId', is_config=True)

  assetKey = __builtin__.property(_get_assetKey, _set_assetKey)
  assetValue = __builtin__.property(_get_assetValue, _set_assetValue)
  assetItems = __builtin__.property(_get_assetItems, _set_assetItems)


  _pyangbind_elements = OrderedDict([('assetKey', assetKey), ('assetValue', assetValue), ('assetItems', assetItems), ])


class yc_switchAssets_sdn_testbed_spec_v2__testbed_apps_config_targetSwitches_switchAssets(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module sdn_testbed_spec_v2 - based on the path /testbed/apps/config/targetSwitches/switchAssets. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__majorAsset','__minorAssets',)

  _yang_name = 'switchAssets'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='int8', is_config=True)
    self.__majorAsset = YANGDynClass(base=yc_majorAsset_sdn_testbed_spec_v2__testbed_apps_config_targetSwitches_switchAssets_majorAsset, is_container='container', yang_name="majorAsset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='container', is_config=True)
    self.__minorAssets = YANGDynClass(base=yc_minorAssets_sdn_testbed_spec_v2__testbed_apps_config_targetSwitches_switchAssets_minorAssets, is_container='container', yang_name="minorAssets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['testbed', 'apps', 'config', 'targetSwitches', 'switchAssets']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /testbed/apps/config/targetSwitches/switchAssets/id (int8)
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /testbed/apps/config/targetSwitches/switchAssets/id (int8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='int8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with int8""",
          'defined-type': "int8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='int8', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='int8', is_config=True)


  def _get_majorAsset(self):
    """
    Getter method for majorAsset, mapped from YANG variable /testbed/apps/config/targetSwitches/switchAssets/majorAsset (container)
    """
    return self.__majorAsset
      
  def _set_majorAsset(self, v, load=False):
    """
    Setter method for majorAsset, mapped from YANG variable /testbed/apps/config/targetSwitches/switchAssets/majorAsset (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_majorAsset is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_majorAsset() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_majorAsset_sdn_testbed_spec_v2__testbed_apps_config_targetSwitches_switchAssets_majorAsset, is_container='container', yang_name="majorAsset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """majorAsset must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_majorAsset_sdn_testbed_spec_v2__testbed_apps_config_targetSwitches_switchAssets_majorAsset, is_container='container', yang_name="majorAsset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='container', is_config=True)""",
        })

    self.__majorAsset = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_majorAsset(self):
    self.__majorAsset = YANGDynClass(base=yc_majorAsset_sdn_testbed_spec_v2__testbed_apps_config_targetSwitches_switchAssets_majorAsset, is_container='container', yang_name="majorAsset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='container', is_config=True)


  def _get_minorAssets(self):
    """
    Getter method for minorAssets, mapped from YANG variable /testbed/apps/config/targetSwitches/switchAssets/minorAssets (container)
    """
    return self.__minorAssets
      
  def _set_minorAssets(self, v, load=False):
    """
    Setter method for minorAssets, mapped from YANG variable /testbed/apps/config/targetSwitches/switchAssets/minorAssets (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_minorAssets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_minorAssets() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_minorAssets_sdn_testbed_spec_v2__testbed_apps_config_targetSwitches_switchAssets_minorAssets, is_container='container', yang_name="minorAssets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """minorAssets must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_minorAssets_sdn_testbed_spec_v2__testbed_apps_config_targetSwitches_switchAssets_minorAssets, is_container='container', yang_name="minorAssets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='container', is_config=True)""",
        })

    self.__minorAssets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_minorAssets(self):
    self.__minorAssets = YANGDynClass(base=yc_minorAssets_sdn_testbed_spec_v2__testbed_apps_config_targetSwitches_switchAssets_minorAssets, is_container='container', yang_name="minorAssets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='container', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  majorAsset = __builtin__.property(_get_majorAsset, _set_majorAsset)
  minorAssets = __builtin__.property(_get_minorAssets, _set_minorAssets)


  _pyangbind_elements = OrderedDict([('id', id), ('majorAsset', majorAsset), ('minorAssets', minorAssets), ])


class yc_targetSwitches_sdn_testbed_spec_v2__testbed_apps_config_targetSwitches(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module sdn_testbed_spec_v2 - based on the path /testbed/apps/config/targetSwitches. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A switch can have invariants as config or assets such as references to hosts or other switches. See description of assetConfig and invariants for details.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__switchInvariants','__switchAssets',)

  _yang_name = 'targetSwitches'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}'}), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='switchId', is_config=True)
    self.__switchInvariants = YANGDynClass(base=YANGListType("invariantKey",yc_switchInvariants_sdn_testbed_spec_v2__testbed_apps_config_targetSwitches_switchInvariants, yang_name="switchInvariants", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='invariantKey', extensions=None), is_container='list', yang_name="switchInvariants", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='list', is_config=True)
    self.__switchAssets = YANGDynClass(base=YANGListType("id",yc_switchAssets_sdn_testbed_spec_v2__testbed_apps_config_targetSwitches_switchAssets, yang_name="switchAssets", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="switchAssets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['testbed', 'apps', 'config', 'targetSwitches']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /testbed/apps/config/targetSwitches/id (switchId)
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /testbed/apps/config/targetSwitches/id (switchId)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}'}), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='switchId', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with switchId""",
          'defined-type': "sdn_testbed_spec_v2:switchId",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}'}), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='switchId', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}'}), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='switchId', is_config=True)


  def _get_switchInvariants(self):
    """
    Getter method for switchInvariants, mapped from YANG variable /testbed/apps/config/targetSwitches/switchInvariants (list)
    """
    return self.__switchInvariants
      
  def _set_switchInvariants(self, v, load=False):
    """
    Setter method for switchInvariants, mapped from YANG variable /testbed/apps/config/targetSwitches/switchInvariants (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_switchInvariants is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_switchInvariants() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("invariantKey",yc_switchInvariants_sdn_testbed_spec_v2__testbed_apps_config_targetSwitches_switchInvariants, yang_name="switchInvariants", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='invariantKey', extensions=None), is_container='list', yang_name="switchInvariants", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """switchInvariants must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("invariantKey",yc_switchInvariants_sdn_testbed_spec_v2__testbed_apps_config_targetSwitches_switchInvariants, yang_name="switchInvariants", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='invariantKey', extensions=None), is_container='list', yang_name="switchInvariants", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='list', is_config=True)""",
        })

    self.__switchInvariants = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_switchInvariants(self):
    self.__switchInvariants = YANGDynClass(base=YANGListType("invariantKey",yc_switchInvariants_sdn_testbed_spec_v2__testbed_apps_config_targetSwitches_switchInvariants, yang_name="switchInvariants", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='invariantKey', extensions=None), is_container='list', yang_name="switchInvariants", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='list', is_config=True)


  def _get_switchAssets(self):
    """
    Getter method for switchAssets, mapped from YANG variable /testbed/apps/config/targetSwitches/switchAssets (list)
    """
    return self.__switchAssets
      
  def _set_switchAssets(self, v, load=False):
    """
    Setter method for switchAssets, mapped from YANG variable /testbed/apps/config/targetSwitches/switchAssets (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_switchAssets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_switchAssets() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_switchAssets_sdn_testbed_spec_v2__testbed_apps_config_targetSwitches_switchAssets, yang_name="switchAssets", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="switchAssets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """switchAssets must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_switchAssets_sdn_testbed_spec_v2__testbed_apps_config_targetSwitches_switchAssets, yang_name="switchAssets", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="switchAssets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='list', is_config=True)""",
        })

    self.__switchAssets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_switchAssets(self):
    self.__switchAssets = YANGDynClass(base=YANGListType("id",yc_switchAssets_sdn_testbed_spec_v2__testbed_apps_config_targetSwitches_switchAssets, yang_name="switchAssets", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="switchAssets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='list', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  switchInvariants = __builtin__.property(_get_switchInvariants, _set_switchInvariants)
  switchAssets = __builtin__.property(_get_switchAssets, _set_switchAssets)


  _pyangbind_elements = OrderedDict([('id', id), ('switchInvariants', switchInvariants), ('switchAssets', switchAssets), ])


class yc_majorAsset_sdn_testbed_spec_v2__testbed_apps_config_appAssets_majorAsset(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module sdn_testbed_spec_v2 - based on the path /testbed/apps/config/appAssets/majorAsset. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__assetKey','__assetValue',)

  _yang_name = 'majorAsset'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__assetKey = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="assetKey", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='string', is_config=True)
    self.__assetValue = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'pc[0-9]{1,2}'}), is_leaf=True, yang_name="assetValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='hostId', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['testbed', 'apps', 'config', 'appAssets', 'majorAsset']

  def _get_assetKey(self):
    """
    Getter method for assetKey, mapped from YANG variable /testbed/apps/config/appAssets/majorAsset/assetKey (string)
    """
    return self.__assetKey
      
  def _set_assetKey(self, v, load=False):
    """
    Setter method for assetKey, mapped from YANG variable /testbed/apps/config/appAssets/majorAsset/assetKey (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_assetKey is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_assetKey() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="assetKey", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """assetKey must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="assetKey", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='string', is_config=True)""",
        })

    self.__assetKey = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_assetKey(self):
    self.__assetKey = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="assetKey", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='string', is_config=True)


  def _get_assetValue(self):
    """
    Getter method for assetValue, mapped from YANG variable /testbed/apps/config/appAssets/majorAsset/assetValue (hostId)
    """
    return self.__assetValue
      
  def _set_assetValue(self, v, load=False):
    """
    Setter method for assetValue, mapped from YANG variable /testbed/apps/config/appAssets/majorAsset/assetValue (hostId)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_assetValue is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_assetValue() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'pc[0-9]{1,2}'}), is_leaf=True, yang_name="assetValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='hostId', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """assetValue must be of a type compatible with hostId""",
          'defined-type': "sdn_testbed_spec_v2:hostId",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'pc[0-9]{1,2}'}), is_leaf=True, yang_name="assetValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='hostId', is_config=True)""",
        })

    self.__assetValue = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_assetValue(self):
    self.__assetValue = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'pc[0-9]{1,2}'}), is_leaf=True, yang_name="assetValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='hostId', is_config=True)

  assetKey = __builtin__.property(_get_assetKey, _set_assetKey)
  assetValue = __builtin__.property(_get_assetValue, _set_assetValue)


  _pyangbind_elements = OrderedDict([('assetKey', assetKey), ('assetValue', assetValue), ])


class yc_minorAssets_sdn_testbed_spec_v2__testbed_apps_config_appAssets_minorAssets(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module sdn_testbed_spec_v2 - based on the path /testbed/apps/config/appAssets/minorAssets. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__assetKey','__assetValue','__assetItems',)

  _yang_name = 'minorAssets'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__assetKey = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="assetKey", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='string', is_config=True)
    self.__assetValue = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}|pc[0-9]{1,2}'}), is_leaf=True, yang_name="assetValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='nodeId', is_config=True)
    self.__assetItems = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}|pc[0-9]{1,2}'})), is_leaf=False, yang_name="assetItems", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='nodeId', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['testbed', 'apps', 'config', 'appAssets', 'minorAssets']

  def _get_assetKey(self):
    """
    Getter method for assetKey, mapped from YANG variable /testbed/apps/config/appAssets/minorAssets/assetKey (string)
    """
    return self.__assetKey
      
  def _set_assetKey(self, v, load=False):
    """
    Setter method for assetKey, mapped from YANG variable /testbed/apps/config/appAssets/minorAssets/assetKey (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_assetKey is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_assetKey() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="assetKey", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """assetKey must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="assetKey", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='string', is_config=True)""",
        })

    self.__assetKey = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_assetKey(self):
    self.__assetKey = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="assetKey", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='string', is_config=True)


  def _get_assetValue(self):
    """
    Getter method for assetValue, mapped from YANG variable /testbed/apps/config/appAssets/minorAssets/assetValue (nodeId)
    """
    return self.__assetValue
      
  def _set_assetValue(self, v, load=False):
    """
    Setter method for assetValue, mapped from YANG variable /testbed/apps/config/appAssets/minorAssets/assetValue (nodeId)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_assetValue is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_assetValue() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}|pc[0-9]{1,2}'}), is_leaf=True, yang_name="assetValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='nodeId', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """assetValue must be of a type compatible with nodeId""",
          'defined-type': "sdn_testbed_spec_v2:nodeId",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}|pc[0-9]{1,2}'}), is_leaf=True, yang_name="assetValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='nodeId', is_config=True)""",
        })

    self.__assetValue = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_assetValue(self):
    self.__assetValue = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}|pc[0-9]{1,2}'}), is_leaf=True, yang_name="assetValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='nodeId', is_config=True)


  def _get_assetItems(self):
    """
    Getter method for assetItems, mapped from YANG variable /testbed/apps/config/appAssets/minorAssets/assetItems (nodeId)
    """
    return self.__assetItems
      
  def _set_assetItems(self, v, load=False):
    """
    Setter method for assetItems, mapped from YANG variable /testbed/apps/config/appAssets/minorAssets/assetItems (nodeId)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_assetItems is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_assetItems() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}|pc[0-9]{1,2}'})), is_leaf=False, yang_name="assetItems", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='nodeId', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """assetItems must be of a type compatible with nodeId""",
          'defined-type': "sdn_testbed_spec_v2:nodeId",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}|pc[0-9]{1,2}'})), is_leaf=False, yang_name="assetItems", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='nodeId', is_config=True)""",
        })

    self.__assetItems = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_assetItems(self):
    self.__assetItems = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}|pc[0-9]{1,2}'})), is_leaf=False, yang_name="assetItems", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='nodeId', is_config=True)

  assetKey = __builtin__.property(_get_assetKey, _set_assetKey)
  assetValue = __builtin__.property(_get_assetValue, _set_assetValue)
  assetItems = __builtin__.property(_get_assetItems, _set_assetItems)


  _pyangbind_elements = OrderedDict([('assetKey', assetKey), ('assetValue', assetValue), ('assetItems', assetItems), ])


class yc_appAssets_sdn_testbed_spec_v2__testbed_apps_config_appAssets(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module sdn_testbed_spec_v2 - based on the path /testbed/apps/config/appAssets. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: An app can reference hosts or switches as assets. See assetConfig for details.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__majorAsset','__minorAssets',)

  _yang_name = 'appAssets'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='int8', is_config=True)
    self.__majorAsset = YANGDynClass(base=yc_majorAsset_sdn_testbed_spec_v2__testbed_apps_config_appAssets_majorAsset, is_container='container', yang_name="majorAsset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='container', is_config=True)
    self.__minorAssets = YANGDynClass(base=yc_minorAssets_sdn_testbed_spec_v2__testbed_apps_config_appAssets_minorAssets, is_container='container', yang_name="minorAssets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['testbed', 'apps', 'config', 'appAssets']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /testbed/apps/config/appAssets/id (int8)
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /testbed/apps/config/appAssets/id (int8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='int8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with int8""",
          'defined-type': "int8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='int8', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='int8', is_config=True)


  def _get_majorAsset(self):
    """
    Getter method for majorAsset, mapped from YANG variable /testbed/apps/config/appAssets/majorAsset (container)
    """
    return self.__majorAsset
      
  def _set_majorAsset(self, v, load=False):
    """
    Setter method for majorAsset, mapped from YANG variable /testbed/apps/config/appAssets/majorAsset (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_majorAsset is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_majorAsset() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_majorAsset_sdn_testbed_spec_v2__testbed_apps_config_appAssets_majorAsset, is_container='container', yang_name="majorAsset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """majorAsset must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_majorAsset_sdn_testbed_spec_v2__testbed_apps_config_appAssets_majorAsset, is_container='container', yang_name="majorAsset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='container', is_config=True)""",
        })

    self.__majorAsset = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_majorAsset(self):
    self.__majorAsset = YANGDynClass(base=yc_majorAsset_sdn_testbed_spec_v2__testbed_apps_config_appAssets_majorAsset, is_container='container', yang_name="majorAsset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='container', is_config=True)


  def _get_minorAssets(self):
    """
    Getter method for minorAssets, mapped from YANG variable /testbed/apps/config/appAssets/minorAssets (container)
    """
    return self.__minorAssets
      
  def _set_minorAssets(self, v, load=False):
    """
    Setter method for minorAssets, mapped from YANG variable /testbed/apps/config/appAssets/minorAssets (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_minorAssets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_minorAssets() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_minorAssets_sdn_testbed_spec_v2__testbed_apps_config_appAssets_minorAssets, is_container='container', yang_name="minorAssets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """minorAssets must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_minorAssets_sdn_testbed_spec_v2__testbed_apps_config_appAssets_minorAssets, is_container='container', yang_name="minorAssets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='container', is_config=True)""",
        })

    self.__minorAssets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_minorAssets(self):
    self.__minorAssets = YANGDynClass(base=yc_minorAssets_sdn_testbed_spec_v2__testbed_apps_config_appAssets_minorAssets, is_container='container', yang_name="minorAssets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='container', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  majorAsset = __builtin__.property(_get_majorAsset, _set_majorAsset)
  minorAssets = __builtin__.property(_get_minorAssets, _set_minorAssets)


  _pyangbind_elements = OrderedDict([('id', id), ('majorAsset', majorAsset), ('minorAssets', minorAssets), ])


class yc_config_sdn_testbed_spec_v2__testbed_apps_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module sdn_testbed_spec_v2 - based on the path /testbed/apps/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__cookie','__appInvariants','__targetSwitches','__appAssets',)

  _yang_name = 'config'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__cookie = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '0x[0-9]+'}), is_leaf=True, yang_name="cookie", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='cookie', is_config=True)
    self.__appInvariants = YANGDynClass(base=YANGListType("invariantKey",yc_appInvariants_sdn_testbed_spec_v2__testbed_apps_config_appInvariants, yang_name="appInvariants", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='invariantKey', extensions=None), is_container='list', yang_name="appInvariants", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='list', is_config=True)
    self.__targetSwitches = YANGDynClass(base=YANGListType("id",yc_targetSwitches_sdn_testbed_spec_v2__testbed_apps_config_targetSwitches, yang_name="targetSwitches", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="targetSwitches", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='list', is_config=True)
    self.__appAssets = YANGDynClass(base=YANGListType("id",yc_appAssets_sdn_testbed_spec_v2__testbed_apps_config_appAssets, yang_name="appAssets", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="appAssets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['testbed', 'apps', 'config']

  def _get_cookie(self):
    """
    Getter method for cookie, mapped from YANG variable /testbed/apps/config/cookie (cookie)
    """
    return self.__cookie
      
  def _set_cookie(self, v, load=False):
    """
    Setter method for cookie, mapped from YANG variable /testbed/apps/config/cookie (cookie)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cookie is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cookie() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '0x[0-9]+'}), is_leaf=True, yang_name="cookie", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='cookie', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cookie must be of a type compatible with cookie""",
          'defined-type': "sdn_testbed_spec_v2:cookie",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '0x[0-9]+'}), is_leaf=True, yang_name="cookie", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='cookie', is_config=True)""",
        })

    self.__cookie = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cookie(self):
    self.__cookie = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '0x[0-9]+'}), is_leaf=True, yang_name="cookie", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='cookie', is_config=True)


  def _get_appInvariants(self):
    """
    Getter method for appInvariants, mapped from YANG variable /testbed/apps/config/appInvariants (list)

    YANG Description: An app can have invariants as config which will be transfered as json dict to the config file. See invariants for details.
    """
    return self.__appInvariants
      
  def _set_appInvariants(self, v, load=False):
    """
    Setter method for appInvariants, mapped from YANG variable /testbed/apps/config/appInvariants (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_appInvariants is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_appInvariants() directly.

    YANG Description: An app can have invariants as config which will be transfered as json dict to the config file. See invariants for details.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("invariantKey",yc_appInvariants_sdn_testbed_spec_v2__testbed_apps_config_appInvariants, yang_name="appInvariants", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='invariantKey', extensions=None), is_container='list', yang_name="appInvariants", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """appInvariants must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("invariantKey",yc_appInvariants_sdn_testbed_spec_v2__testbed_apps_config_appInvariants, yang_name="appInvariants", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='invariantKey', extensions=None), is_container='list', yang_name="appInvariants", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='list', is_config=True)""",
        })

    self.__appInvariants = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_appInvariants(self):
    self.__appInvariants = YANGDynClass(base=YANGListType("invariantKey",yc_appInvariants_sdn_testbed_spec_v2__testbed_apps_config_appInvariants, yang_name="appInvariants", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='invariantKey', extensions=None), is_container='list', yang_name="appInvariants", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='list', is_config=True)


  def _get_targetSwitches(self):
    """
    Getter method for targetSwitches, mapped from YANG variable /testbed/apps/config/targetSwitches (list)

    YANG Description: A switch can have invariants as config or assets such as references to hosts or other switches. See description of assetConfig and invariants for details.
    """
    return self.__targetSwitches
      
  def _set_targetSwitches(self, v, load=False):
    """
    Setter method for targetSwitches, mapped from YANG variable /testbed/apps/config/targetSwitches (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_targetSwitches is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_targetSwitches() directly.

    YANG Description: A switch can have invariants as config or assets such as references to hosts or other switches. See description of assetConfig and invariants for details.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_targetSwitches_sdn_testbed_spec_v2__testbed_apps_config_targetSwitches, yang_name="targetSwitches", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="targetSwitches", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """targetSwitches must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_targetSwitches_sdn_testbed_spec_v2__testbed_apps_config_targetSwitches, yang_name="targetSwitches", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="targetSwitches", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='list', is_config=True)""",
        })

    self.__targetSwitches = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_targetSwitches(self):
    self.__targetSwitches = YANGDynClass(base=YANGListType("id",yc_targetSwitches_sdn_testbed_spec_v2__testbed_apps_config_targetSwitches, yang_name="targetSwitches", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="targetSwitches", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='list', is_config=True)


  def _get_appAssets(self):
    """
    Getter method for appAssets, mapped from YANG variable /testbed/apps/config/appAssets (list)

    YANG Description: An app can reference hosts or switches as assets. See assetConfig for details.
    """
    return self.__appAssets
      
  def _set_appAssets(self, v, load=False):
    """
    Setter method for appAssets, mapped from YANG variable /testbed/apps/config/appAssets (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_appAssets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_appAssets() directly.

    YANG Description: An app can reference hosts or switches as assets. See assetConfig for details.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_appAssets_sdn_testbed_spec_v2__testbed_apps_config_appAssets, yang_name="appAssets", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="appAssets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """appAssets must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_appAssets_sdn_testbed_spec_v2__testbed_apps_config_appAssets, yang_name="appAssets", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="appAssets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='list', is_config=True)""",
        })

    self.__appAssets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_appAssets(self):
    self.__appAssets = YANGDynClass(base=YANGListType("id",yc_appAssets_sdn_testbed_spec_v2__testbed_apps_config_appAssets, yang_name="appAssets", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="appAssets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='list', is_config=True)

  cookie = __builtin__.property(_get_cookie, _set_cookie)
  appInvariants = __builtin__.property(_get_appInvariants, _set_appInvariants)
  targetSwitches = __builtin__.property(_get_targetSwitches, _set_targetSwitches)
  appAssets = __builtin__.property(_get_appAssets, _set_appAssets)


  _pyangbind_elements = OrderedDict([('cookie', cookie), ('appInvariants', appInvariants), ('targetSwitches', targetSwitches), ('appAssets', appAssets), ])


class yc_apps_sdn_testbed_spec_v2__testbed_apps(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module sdn_testbed_spec_v2 - based on the path /testbed/apps. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__config',)

  _yang_name = 'apps'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='string', is_config=True)
    self.__config = YANGDynClass(base=yc_config_sdn_testbed_spec_v2__testbed_apps_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['testbed', 'apps']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /testbed/apps/id (string)
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /testbed/apps/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='string', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /testbed/apps/config (container)
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /testbed/apps/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_sdn_testbed_spec_v2__testbed_apps_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_sdn_testbed_spec_v2__testbed_apps_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_sdn_testbed_spec_v2__testbed_apps_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='container', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  config = __builtin__.property(_get_config, _set_config)


  _pyangbind_elements = OrderedDict([('id', id), ('config', config), ])


class yc_switches_sdn_testbed_spec_v2__testbed_switches(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module sdn_testbed_spec_v2 - based on the path /testbed/switches. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of unique switches in the testbed.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id',)

  _yang_name = 'switches'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}'}), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='switchId', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['testbed', 'switches']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /testbed/switches/id (switchId)
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /testbed/switches/id (switchId)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}'}), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='switchId', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with switchId""",
          'defined-type': "sdn_testbed_spec_v2:switchId",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}'}), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='switchId', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}'}), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='switchId', is_config=True)

  id = __builtin__.property(_get_id, _set_id)


  _pyangbind_elements = OrderedDict([('id', id), ])


class yc_hosts_sdn_testbed_spec_v2__testbed_hosts(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module sdn_testbed_spec_v2 - based on the path /testbed/hosts. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of host nodes in the topology. The source attribute specifies wheather a host will be used as a source for network traffic in a test configuration. Default is false, so host will be a sink.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__source',)

  _yang_name = 'hosts'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'pc[0-9]{1,2}'}), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='hostId', is_config=True)
    self.__source = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['testbed', 'hosts']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /testbed/hosts/id (hostId)
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /testbed/hosts/id (hostId)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'pc[0-9]{1,2}'}), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='hostId', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with hostId""",
          'defined-type': "sdn_testbed_spec_v2:hostId",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'pc[0-9]{1,2}'}), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='hostId', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'pc[0-9]{1,2}'}), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='hostId', is_config=True)


  def _get_source(self):
    """
    Getter method for source, mapped from YANG variable /testbed/hosts/source (boolean)
    """
    return self.__source
      
  def _set_source(self, v, load=False):
    """
    Setter method for source, mapped from YANG variable /testbed/hosts/source (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='boolean', is_config=True)""",
        })

    self.__source = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source(self):
    self.__source = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='boolean', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  source = __builtin__.property(_get_source, _set_source)


  _pyangbind_elements = OrderedDict([('id', id), ('source', source), ])


class yc_edges_sdn_testbed_spec_v2__testbed_edges(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module sdn_testbed_spec_v2 - based on the path /testbed/edges. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__nodes',)

  _yang_name = 'edges'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='uint8', is_config=True)
    self.__nodes = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}|pc[0-9]{1,2}'})), is_leaf=False, yang_name="nodes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='nodeId', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['testbed', 'edges']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /testbed/edges/id (uint8)
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /testbed/edges/id (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='uint8', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='uint8', is_config=True)


  def _get_nodes(self):
    """
    Getter method for nodes, mapped from YANG variable /testbed/edges/nodes (nodeId)
    """
    return self.__nodes
      
  def _set_nodes(self, v, load=False):
    """
    Setter method for nodes, mapped from YANG variable /testbed/edges/nodes (nodeId)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nodes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nodes() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}|pc[0-9]{1,2}'})), is_leaf=False, yang_name="nodes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='nodeId', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nodes must be of a type compatible with nodeId""",
          'defined-type': "sdn_testbed_spec_v2:nodeId",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}|pc[0-9]{1,2}'})), is_leaf=False, yang_name="nodes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='nodeId', is_config=True)""",
        })

    self.__nodes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nodes(self):
    self.__nodes = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': 'router[0-9]{1,2}|pc[0-9]{1,2}'})), is_leaf=False, yang_name="nodes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='nodeId', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  nodes = __builtin__.property(_get_nodes, _set_nodes)


  _pyangbind_elements = OrderedDict([('id', id), ('nodes', nodes), ])


class yc_testbed_sdn_testbed_spec_v2__testbed(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module sdn_testbed_spec_v2 - based on the path /testbed. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__topologyId','__autostart','__evaluationRun','__bw_difference_threshold','__apps','__trafficProfiles','__trafficTypes','__switches','__hosts','__edges',)

  _yang_name = 'testbed'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__topologyId = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="topologyId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='string', is_config=True)
    self.__autostart = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="autostart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='boolean', is_config=True)
    self.__evaluationRun = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="evaluationRun", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='boolean', is_config=True)
    self.__bw_difference_threshold = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="bw_difference_threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='uint8', is_config=True)
    self.__apps = YANGDynClass(base=YANGListType("id",yc_apps_sdn_testbed_spec_v2__testbed_apps, yang_name="apps", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="apps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='list', is_config=True)
    self.__trafficProfiles = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'cbr': {}, 'vbr': {}, 'bursty': {}},)), is_leaf=False, yang_name="trafficProfiles", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='trafficProfile', is_config=True)
    self.__trafficTypes = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'tcp': {}, 'udp': {}},)), is_leaf=False, yang_name="trafficTypes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='trafficType', is_config=True)
    self.__switches = YANGDynClass(base=YANGListType("id",yc_switches_sdn_testbed_spec_v2__testbed_switches, yang_name="switches", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="switches", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='list', is_config=True)
    self.__hosts = YANGDynClass(base=YANGListType("id",yc_hosts_sdn_testbed_spec_v2__testbed_hosts, yang_name="hosts", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="hosts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='list', is_config=True)
    self.__edges = YANGDynClass(base=YANGListType("id",yc_edges_sdn_testbed_spec_v2__testbed_edges, yang_name="edges", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="edges", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['testbed']

  def _get_topologyId(self):
    """
    Getter method for topologyId, mapped from YANG variable /testbed/topologyId (string)

    YANG Description: Unique identifer for the topology.
    """
    return self.__topologyId
      
  def _set_topologyId(self, v, load=False):
    """
    Setter method for topologyId, mapped from YANG variable /testbed/topologyId (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_topologyId is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_topologyId() directly.

    YANG Description: Unique identifer for the topology.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="topologyId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """topologyId must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="topologyId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='string', is_config=True)""",
        })

    self.__topologyId = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_topologyId(self):
    self.__topologyId = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="topologyId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='string', is_config=True)


  def _get_autostart(self):
    """
    Getter method for autostart, mapped from YANG variable /testbed/autostart (boolean)

    YANG Description: If this boolean is set to true, the topology will be built, nodes and the controller are configured and the experiment based on this config file will be run automatically.
    """
    return self.__autostart
      
  def _set_autostart(self, v, load=False):
    """
    Setter method for autostart, mapped from YANG variable /testbed/autostart (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_autostart is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_autostart() directly.

    YANG Description: If this boolean is set to true, the topology will be built, nodes and the controller are configured and the experiment based on this config file will be run automatically.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="autostart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """autostart must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="autostart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='boolean', is_config=True)""",
        })

    self.__autostart = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_autostart(self):
    self.__autostart = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="autostart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='boolean', is_config=True)


  def _get_evaluationRun(self):
    """
    Getter method for evaluationRun, mapped from YANG variable /testbed/evaluationRun (boolean)

    YANG Description: If this boolean is set to true any errors for failed connections will be ignored to allow for evaluation of intended failures (e.g. with intended loops).
    """
    return self.__evaluationRun
      
  def _set_evaluationRun(self, v, load=False):
    """
    Setter method for evaluationRun, mapped from YANG variable /testbed/evaluationRun (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_evaluationRun is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_evaluationRun() directly.

    YANG Description: If this boolean is set to true any errors for failed connections will be ignored to allow for evaluation of intended failures (e.g. with intended loops).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="evaluationRun", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """evaluationRun must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="evaluationRun", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='boolean', is_config=True)""",
        })

    self.__evaluationRun = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_evaluationRun(self):
    self.__evaluationRun = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="evaluationRun", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='boolean', is_config=True)


  def _get_bw_difference_threshold(self):
    """
    Getter method for bw_difference_threshold, mapped from YANG variable /testbed/bw_difference_threshold (uint8)

    YANG Description: All target switch ports of an app will be checked for their bandwidth and compared to this value for determining an error.
    """
    return self.__bw_difference_threshold
      
  def _set_bw_difference_threshold(self, v, load=False):
    """
    Setter method for bw_difference_threshold, mapped from YANG variable /testbed/bw_difference_threshold (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bw_difference_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bw_difference_threshold() directly.

    YANG Description: All target switch ports of an app will be checked for their bandwidth and compared to this value for determining an error.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="bw_difference_threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bw_difference_threshold must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="bw_difference_threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='uint8', is_config=True)""",
        })

    self.__bw_difference_threshold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bw_difference_threshold(self):
    self.__bw_difference_threshold = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="bw_difference_threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='uint8', is_config=True)


  def _get_apps(self):
    """
    Getter method for apps, mapped from YANG variable /testbed/apps (list)
    """
    return self.__apps
      
  def _set_apps(self, v, load=False):
    """
    Setter method for apps, mapped from YANG variable /testbed/apps (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_apps is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_apps() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_apps_sdn_testbed_spec_v2__testbed_apps, yang_name="apps", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="apps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """apps must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_apps_sdn_testbed_spec_v2__testbed_apps, yang_name="apps", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="apps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='list', is_config=True)""",
        })

    self.__apps = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_apps(self):
    self.__apps = YANGDynClass(base=YANGListType("id",yc_apps_sdn_testbed_spec_v2__testbed_apps, yang_name="apps", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="apps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='list', is_config=True)


  def _get_trafficProfiles(self):
    """
    Getter method for trafficProfiles, mapped from YANG variable /testbed/trafficProfiles (trafficProfile)

    YANG Description: Traffic profile can be cbr, vbr or bursty
    """
    return self.__trafficProfiles
      
  def _set_trafficProfiles(self, v, load=False):
    """
    Setter method for trafficProfiles, mapped from YANG variable /testbed/trafficProfiles (trafficProfile)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_trafficProfiles is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_trafficProfiles() directly.

    YANG Description: Traffic profile can be cbr, vbr or bursty
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'cbr': {}, 'vbr': {}, 'bursty': {}},)), is_leaf=False, yang_name="trafficProfiles", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='trafficProfile', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """trafficProfiles must be of a type compatible with trafficProfile""",
          'defined-type': "sdn_testbed_spec_v2:trafficProfile",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'cbr': {}, 'vbr': {}, 'bursty': {}},)), is_leaf=False, yang_name="trafficProfiles", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='trafficProfile', is_config=True)""",
        })

    self.__trafficProfiles = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_trafficProfiles(self):
    self.__trafficProfiles = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'cbr': {}, 'vbr': {}, 'bursty': {}},)), is_leaf=False, yang_name="trafficProfiles", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='trafficProfile', is_config=True)


  def _get_trafficTypes(self):
    """
    Getter method for trafficTypes, mapped from YANG variable /testbed/trafficTypes (trafficType)

    YANG Description: Traffic type can be tcp or udp
    """
    return self.__trafficTypes
      
  def _set_trafficTypes(self, v, load=False):
    """
    Setter method for trafficTypes, mapped from YANG variable /testbed/trafficTypes (trafficType)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_trafficTypes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_trafficTypes() directly.

    YANG Description: Traffic type can be tcp or udp
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'tcp': {}, 'udp': {}},)), is_leaf=False, yang_name="trafficTypes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='trafficType', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """trafficTypes must be of a type compatible with trafficType""",
          'defined-type': "sdn_testbed_spec_v2:trafficType",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'tcp': {}, 'udp': {}},)), is_leaf=False, yang_name="trafficTypes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='trafficType', is_config=True)""",
        })

    self.__trafficTypes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_trafficTypes(self):
    self.__trafficTypes = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'tcp': {}, 'udp': {}},)), is_leaf=False, yang_name="trafficTypes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='trafficType', is_config=True)


  def _get_switches(self):
    """
    Getter method for switches, mapped from YANG variable /testbed/switches (list)

    YANG Description: List of unique switches in the testbed.
    """
    return self.__switches
      
  def _set_switches(self, v, load=False):
    """
    Setter method for switches, mapped from YANG variable /testbed/switches (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_switches is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_switches() directly.

    YANG Description: List of unique switches in the testbed.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_switches_sdn_testbed_spec_v2__testbed_switches, yang_name="switches", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="switches", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """switches must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_switches_sdn_testbed_spec_v2__testbed_switches, yang_name="switches", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="switches", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='list', is_config=True)""",
        })

    self.__switches = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_switches(self):
    self.__switches = YANGDynClass(base=YANGListType("id",yc_switches_sdn_testbed_spec_v2__testbed_switches, yang_name="switches", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="switches", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='list', is_config=True)


  def _get_hosts(self):
    """
    Getter method for hosts, mapped from YANG variable /testbed/hosts (list)

    YANG Description: List of host nodes in the topology. The source attribute specifies wheather a host will be used as a source for network traffic in a test configuration. Default is false, so host will be a sink.
    """
    return self.__hosts
      
  def _set_hosts(self, v, load=False):
    """
    Setter method for hosts, mapped from YANG variable /testbed/hosts (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hosts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hosts() directly.

    YANG Description: List of host nodes in the topology. The source attribute specifies wheather a host will be used as a source for network traffic in a test configuration. Default is false, so host will be a sink.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_hosts_sdn_testbed_spec_v2__testbed_hosts, yang_name="hosts", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="hosts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hosts must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_hosts_sdn_testbed_spec_v2__testbed_hosts, yang_name="hosts", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="hosts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='list', is_config=True)""",
        })

    self.__hosts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hosts(self):
    self.__hosts = YANGDynClass(base=YANGListType("id",yc_hosts_sdn_testbed_spec_v2__testbed_hosts, yang_name="hosts", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="hosts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='list', is_config=True)


  def _get_edges(self):
    """
    Getter method for edges, mapped from YANG variable /testbed/edges (list)
    """
    return self.__edges
      
  def _set_edges(self, v, load=False):
    """
    Setter method for edges, mapped from YANG variable /testbed/edges (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_edges is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_edges() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_edges_sdn_testbed_spec_v2__testbed_edges, yang_name="edges", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="edges", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """edges must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_edges_sdn_testbed_spec_v2__testbed_edges, yang_name="edges", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="edges", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='list', is_config=True)""",
        })

    self.__edges = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_edges(self):
    self.__edges = YANGDynClass(base=YANGListType("id",yc_edges_sdn_testbed_spec_v2__testbed_edges, yang_name="edges", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="edges", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='list', is_config=True)

  topologyId = __builtin__.property(_get_topologyId, _set_topologyId)
  autostart = __builtin__.property(_get_autostart, _set_autostart)
  evaluationRun = __builtin__.property(_get_evaluationRun, _set_evaluationRun)
  bw_difference_threshold = __builtin__.property(_get_bw_difference_threshold, _set_bw_difference_threshold)
  apps = __builtin__.property(_get_apps, _set_apps)
  trafficProfiles = __builtin__.property(_get_trafficProfiles, _set_trafficProfiles)
  trafficTypes = __builtin__.property(_get_trafficTypes, _set_trafficTypes)
  switches = __builtin__.property(_get_switches, _set_switches)
  hosts = __builtin__.property(_get_hosts, _set_hosts)
  edges = __builtin__.property(_get_edges, _set_edges)


  _pyangbind_elements = OrderedDict([('topologyId', topologyId), ('autostart', autostart), ('evaluationRun', evaluationRun), ('bw_difference_threshold', bw_difference_threshold), ('apps', apps), ('trafficProfiles', trafficProfiles), ('trafficTypes', trafficTypes), ('switches', switches), ('hosts', hosts), ('edges', edges), ])


class sdn_testbed_spec_v2(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module sdn_testbed_spec_v2 - based on the path /sdn_testbed_spec_v2. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__testbed',)

  _yang_name = 'sdn_testbed_spec_v2'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__testbed = YANGDynClass(base=yc_testbed_sdn_testbed_spec_v2__testbed, is_container='container', yang_name="testbed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_testbed(self):
    """
    Getter method for testbed, mapped from YANG variable /testbed (container)
    """
    return self.__testbed
      
  def _set_testbed(self, v, load=False):
    """
    Setter method for testbed, mapped from YANG variable /testbed (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_testbed is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_testbed() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_testbed_sdn_testbed_spec_v2__testbed, is_container='container', yang_name="testbed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """testbed must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_testbed_sdn_testbed_spec_v2__testbed, is_container='container', yang_name="testbed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='container', is_config=True)""",
        })

    self.__testbed = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_testbed(self):
    self.__testbed = YANGDynClass(base=yc_testbed_sdn_testbed_spec_v2__testbed, is_container='container', yang_name="testbed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='uri:yang:sdn', defining_module='sdn_testbed_spec_v2', yang_type='container', is_config=True)

  testbed = __builtin__.property(_get_testbed, _set_testbed)


  _pyangbind_elements = OrderedDict([('testbed', testbed), ])


