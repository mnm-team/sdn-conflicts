#version 2: read file from the dataset
# version 1: read file via ssh to the target router, not from the dataset

#!/bin/bash
#note: bash has to support array, in order to run this code, bash_version 2.x onwards does.

# The name "one app" is self-explanatory, to run a single app only, it is different from one point: a point corresponds to a point in the parameter space which containing several control apps in a specific setting of e.g., priority of each control apps, their target switch.

# The first 8 lines of the <all_config> config file, which is dataset/$3/all_config, is the configuration for the experiment, and the control app name must be **EXACTLY** present in this file.

usage(){
echo "To run a single app only"
#echo "Usage: bash one_app.bash <app name> <config> <all_config file>"
echo "Usage: bash one_app.bash <app name> <config> <experiment round id>"
echo "E.g.: bash one_app.bash pplb 1 200818_160647"
}

[ $# -ne 3 ] && usage && exit 1

#input="parameter_space.bash"
input="dataset/$3/all_config"
[ ! -f $input ] && echo "File $input does not exist! Exit now" && exit 1
sed -n 1p $input | grep -w $1
[ $? -ne 0 ] && echo "control app is not present in the parameter_space.bash, exit now!" && exit 1

. ./collectdata_config.bash

#switch the massive directory in the controller to the state logged by the gitcommitid in all_config
gitcommitid=$(grep gitcommitid $all_config | cut -d'=' -f2)
ssh -n con0 "sh -c 'cd $APPDIR; git log | grep $gitcommitid'"
[ $? -ne 0 ] && echo "There is no state corresponding to the gitcommitid shown in all_config, exit now!" && exit 1
ssh -n con0 "sh -c 'cd $APPDIR; git checkout $gitcommitid'"


i=1
while IFS= read -r line
do
  if [ -z "$line" ]; then
      break
  fi
  echo "line $i: $line" #| awk '$1=="APPS" {print $1 " " $2 " " $3}'
  if [ $i -eq 1 ]; then #process APPS
	apps=($line) #initiate an array
	#echo ${apps[*]} #the whole array string
	#echo ${#apps[@]} #number of array elements
	for (( index=0; index<${#apps[@]}; index++ ))
	do
	  echo ${apps[$index]}
	done
  fi
  if [ $i -eq 2 ]; then #process APPCONF
	appconf=($line)
	for (( index=0; index<${#appconf[@]}; index++ ))
	do
	  echo ${appconf[$index]}
	done
	#test=$(( ${appconf[1]}+4 ))
	#echo "test=$test"
	#TODO make appconfig global, then it is not local to the app and the
	#outside script could process it, e.g., the script could know for eplb
	#which end-points should be involed (be server at once)
  fi
  if [ $i -eq 3 ]; then #process TRANS, transport type
	trans=($line)
	for (( index=0; index<${#trans[@]}; index++ ))
	do
	  echo ${trans[$index]}
	done
  fi
  if [ $i -eq 4 ]; then #process TARGETSW
	IFS=':' read -ra ts <<< $line
	for j in "${ts[@]}"; do echo $j; done #ts=target switch
  fi
  if [ $i -eq 5 ]; then #process EPTRAFPROF
	#echo "line $i"
	trafprof=($line)
	for (( index=0; index<${#trafprof[@]}; index++ ))
	do
	  echo ${trafprof[$index]}
	done
  fi
  if [ $i -eq 6 ]; then #process NUMSW
	#echo "line $i"
	numsw=$line
	echo "number of switches = $numsw"
  fi
  if [ $i -eq 7 ]; then #process NUMEP
	numep=$line
	echo "number of end-points = $numep"
  fi
  if [ $i -eq 8 ]; then #process EPCOMBI
	IFS=':' read -ra comb <<< $line
	for j in "${comb[@]}"; do echo $j; done #comb=endpoint combination
  fi
  let i=$i+1 #or i=$(( $i+1 )) or let i++
done < "$input"

echo "Deploy application $1 with configuration $2 in isolation to observe the expected network behaviour."
for (( i_a=0; i_a<${#apps[@]}; i_a++ )) #index_application
do
  if [[ ${apps[$i_a]} != "$1" ]]; then
     continue
  fi
  echo ${apps[$i_a]}
  file=${apps[$i_a]}_config_global
  echo "#config: ${appconf[$i_a]}"
  [ $2 -gt ${appconf[$i_a]} ] && echo "App $1 has no configuration $2, exit" && exit 1
  echo "2 #priority" > $file
  echo "${ts[$i_a]} #target switches" >> $file
  echo "$2 #app config" >> $file
  echo >> $file
  echo "[global] #generated by the script from outer machine" >> $file
  echo "content of $file"
  cat $file    
  scp $file con0:$APPDIR #con0 is the hostname of the controller0
  # adapt the local config file of the control app (CA): each CA has in *massive* directory of con0 the local1/2/3... file, choose one to be the *local*.
  ssh -n con0 "sh -c 'cd $APPDIR; cp ${apps[$i_a]}_config_local$2 ${apps[$i_a]}_config_local'"
 
  #run controller
  #generate traffic at end-point
  #TODO: loop through end-point traffic profile and end-point combination dimensions
  #dump traffic in involved end-points and routers, observe the path
  #stop end-point, stop controller
  
  #echo "list_app = $list_app"
  #clean the environment for experiment
  bash collectdata_stop_and_clean.bash $numsw $numep

  bash collectdata_controller.bash ${apps[$i_a]}
  [ $? -eq 11 ] && echo "Controller is not running, please check! Terminate!" && exit 1
  #bash collectdata_dataplane.bash 0 "${comb[0]}" "${comb[1]}"
  bash collectdata_dataplane_single.bash "${apps[$i_a]}_$2" "${comb[0]}" "${comb[1]}" $numsw
  #bash collectdata_stop_and_clean.bash $numsw $numep
  #exit_code=$?
  #[ $exit_code -ne 0 ] && echo "stop and clean error!, exit code $exit_code" | tee -a conflict.txt && exit 1
  break
done #end deploying in isolation

#retore the massive directory of the controller back to the latest state.
ssh -n con0 "sh -c 'cd $APPDIR; git checkout master'"
