#!/bin/bash
#note: bash has to support array, in order to run this code, bash_version 2.x onwards does.
input="parameter_space.bash"
. ./collectdata_config.bash
. ./collectdata_function.bash
# cleaning
datesuffix=$(date +"%y%m%d_%H%M%S")
id=$datesuffix
cp all_config all_config$datesuffix
cp conflict.txt conflict$datesuffix.txt
# clean dataplane and host data
bash collectdata_stop_and_clean.bash $numsw $numep
exit_code=$?
[ $exit_code -ne 0 ] && echo "stop and clean error!, exit code $exit_code" | tee -a conflict.txt && exit 1
> all_config
> conflict.txt
rm temp.txt 

sed -n 1,10p parameter_space.bash > all_config

echo $id >> all_config
echo $id > conflict.txt

i=1
while IFS= read -r line
do
  if [ -z "$line" ]; then
      break
  fi
  echo "line $i: $line" #| awk '$1=="APPS" {print $1 " " $2 " " $3}'
  if [ $i -eq 1 ]; then #process APPS
	apps=($line) #initiate an array
	#echo ${apps[*]} #the whole array string
	#echo ${#apps[@]} #number of array elements
	for (( index=0; index<${#apps[@]}; index++ ))
	do
	  echo ${apps[$index]}
	done
  fi
  if [ $i -eq 2 ]; then #process APPCONF
	appconf=($line)
	for (( index=0; index<${#appconf[@]}; index++ ))
	do
	  echo ${appconf[$index]}
	done
	#test=$(( ${appconf[1]}+4 ))
	#echo "test=$test"
	#TODO make appconfig global, then it is not local to the app and the
	#outside script could process it, e.g., the script could know for eplb
	#which end-points should be involed (be server at once)
  fi
  if [ $i -eq 3 ]; then #process TRANS, transport type
	trans=($line)
	for (( index=0; index<${#trans[@]}; index++ ))
	do
	  echo ${trans[$index]}
	done
  fi
  if [ $i -eq 4 ]; then #process TARGETSW
	IFS=':' read -ra ts <<< $line
	for j in "${ts[@]}"; do echo $j; done #ts=target switch
  fi
  if [ $i -eq 5 ]; then #process EPTRAFPROF
	#echo "line $i"
	trafprof=($line)
	for (( index=0; index<${#trafprof[@]}; index++ ))
	do
	  echo ${trafprof[$index]}
	done
  fi
  if [ $i -eq 6 ]; then #process NUMSW
	#echo "line $i"
	numsw=$line
	echo "number of switches = $numsw"
  fi
  if [ $i -eq 7 ]; then #process NUMEP
	numep=$line
	echo "number of end-points = $numep"
  fi
  if [ $i -eq 8 ]; then #process EPCOMBI
	IFS=':' read -ra comb <<< $line
	for j in "${comb[@]}"; do echo $j; done #comb=endpoint combination
  fi
  if [ $i -eq 9 ]; then #process topology name
	id="${line}_${id}"
	echo "Id for this experiment is ${id}"
  fi
  let i=$i+1 #or i=$(( $i+1 )) or let i++
done < "$input"

echo "remove all router*_dumpflows_* from all routers/switches to prepare fresh data for the dataset"
for i in $(seq 1 $numsw); do ssh -n router$i "sh -c 'rm -f router$i\_dumpflows*'"; done
echo "remove all tmp* files from all end-points to have fresh data for comparison between expected and observed network behaviour at end-points"
for i in $(seq 1 $numep); do ssh -n pc$i "sh -c 'rm -f tmp*'"; done


#>rsync_massive.txt #file refered to by rsync to synchronize massive directory to dataset
#echo "IGNORE temporarily Deploy each application in isolation to derive the expected network behaviour."
echo "Deploy each application in isolation to derive the expected network behaviour."
for (( i_a=0; i_a<${#apps[@]}; i_a++ )) #index_application
do
  echo ${apps[$i_a]}
  #echo ${apps[$i_a]}.py >> rsync_massive.txt
  file=${apps[$i_a]}_config_global
  echo "#config: ${appconf[$i_a]}"
  for (( c=1; c<=${appconf[$i_a]};c++ )); do #config
    echo $c
    echo "2 #priority" > $file
    echo "${ts[$i_a]} #target switches" >> $file
    echo "$c #app config" >> $file
    echo >> $file
    echo "[global] #generated by the script from outer machine" >> $file
    echo "content of $file"
    cat $file    
    scp $file con0:$APPDIR #con0 is the hostname of the controller0
    # adapt the local config file of the control app (CA): each CA has in *massive* directory of con0 the local1/2/3... file, choose one to be the *local*.
    ssh -n con0 "sh -c 'cd $APPDIR; cp ${apps[$i_a]}_config_local$c ${apps[$i_a]}_config_local; git add ${apps[$i_a]}.py ${apps[$i_a]}_config_local$c'"
    #echo ${apps[$i_a]}_config_local$c >> rsync_massive.txt

    #run controller
    #generate traffic at end-point
    #TODO: loop through end-point traffic profile and end-point combination dimensions
    #dump traffic in involved end-points and routers, observe the path
    #stop end-point, stop controller
    
    #echo "list_app = $list_app"
    bash collectdata_controller.bash ${apps[$i_a]}
    #bash collectdata_dataplane.bash 0 "${comb[0]}" "${comb[1]}"
    bash collectdata_dataplane.bash "${apps[$i_a]}_$c" "${comb[0]}" "${comb[1]}" $numsw "iso" # $5 is a dummy variable to check if this is an isolated run for the firewall
    bash collectdata_stop_and_clean.bash $numsw $numep
    exit_code=$?
    [ $exit_code -ne 0 ] && echo "stop and clean error!, exit code $exit_code" | tee -a conflict.txt && exit 1
  done
done #end deploying in isolation

grep point conflict.txt 
if [ $? -eq 0 ]; then
  echo "There is problem while deploying control apps in isolation, check conflict.txt, exit now!"
  echo "Note that: the destination list in parameter_space.bash has to cover all the end-points in local config of all control apps."
  #bash collectdata_stop_and_clean.bash $numsw $numep
  mkdir -p topology_errors
  cp conflict.txt topology_errors/"$id.txt"
  cp parameter_space.json topology_errors/"$id.json"
  exit 1
fi
# git commit all changes in the con0:$APPDIR, get the commit id and store the commit id in the all_config file, so that the one_app.bash and one_point.bash can restore all the configuration from the dataset
ssh -n con0 "sh -c 'cd $APPDIR; git commit -am \".\"; git push'"
echo -n "gitcommitid=" >> all_config
ssh -n con0 "sh -c 'cd $APPDIR; git log -n 1 --format=format:\"%H\" '" >> all_config #store the commit hash in all_config.
echo >> all_config
#storing app:
(cd dataset/massive; git pull)
#rsync -av --existing con0:$APPDIR/ dataset/massive/
#rsync -av --files-from=rsync_massive.txt con0:$APPDIR/ dataset/massive/

#exit

#pick a window of at least 2 apps:
#for (( win=2; win<=${#apps[@]}; win++ )); do
#   echo "test"
#done

#python choose_app.py ${#apps[@]} | tee app_choice
python choose_app.py ${#apps[@]} > app_choice

#i=1
#while IFS= read -r line
#do
#  echo "apps combination $i:"
#  ch=($line) #choice
#  for (( index=0; index<${#ch[@]}; index++ ))
#  do
#    echo "${ch[$index]}: ${apps[${ch[$index]}-1]}"
#  done
#let i++  
#done < "app_choice"

#priority is dependent on each combination of app choice, e.g., if there're two
#apps, priority will be 2 2, 2 3, 3 2. If there're 3 apps, it is 2 2 2, 2 2 3...

#target switches is stored above

#app config is derived from the number of configurations each app has.

#loop through parameter space:
#choose application combination:
point=1
while IFS= read -r line; do
  ch=($line) #choice
  tmp_cfg_arg="" #temp_config_argument
  for (( index=0; index<${#ch[@]}; index++ )); do
    #echo "${ch[$index]}: ${apps[${ch[$index]}]}: ${appconf[${ch[$index]}]}"
    echo "${apps[${ch[$index]}]}: ${appconf[${ch[$index]}]}"
    tmp_cfg_arg="$tmp_cfg_arg ${appconf[${ch[$index]}]}" 
  done
  #echo "tmp_cfg_arg = $tmp_cfg_arg"
  python generate_config.py $tmp_cfg_arg > app_config
  echo "All app config combinations:"
  cat app_config
  #now, having the app_config dimension, loop through it again.
  while IFS= read -r line_appcfg; do
    conf=($line_appcfg)
    [ ${#conf[@]} -lt ${#ch[@]} ] && echo "less than, continue!" && continue 
    [ ${#conf[@]} -gt ${#ch[@]} ] && echo "greater than, break!" && break
    #with current way of generating config, above 2 cases don't happen
    for (( i_cf=0; i_cf<${#conf[@]}; i_cf++ )); do #index config
      echo "${ch[$i_cf]}: ${apps[${ch[$i_cf]}]}:${conf[$i_cf]}"
    done
    #ignore app start order
    #continue with app priority
    while IFS= read -r line_pri; do
      [ -z "$line_pri" ] && break
      echo "priority: $line_pri"
      pri=($line_pri)
      echo "point $point" >> all_config
      list_app="null"
      max_pri=2 # used in comparing the expected and real/observed network behaviour later
      for (( i_pri=0; i_pri<${#pri[@]}; i_pri++ )); do #index priority
        echo "${apps[${ch[$i_pri]}]}:${conf[$i_pri]}:${pri[$i_pri]}:${ts[${ch[$i_pri]}]}" | tee -a all_config
        #echo "point $point:${apps[${ch[$i_pri]}]}:${conf[$i_pri]}:${pri[$i_pri]}"
        #let point++
	#loop to next dimension, target switch: already done above
	#now enough to write config file for SDN applications of inner controller in machine con0
	echo "Point $point: Generating config for ${apps[${ch[$i_pri]}]}"
	file=${apps[${ch[$i_pri]}]}_config_global
	echo "${pri[$i_pri]} #priority" > $file
	echo "${ts[${ch[$i_pri]}]} #target switches" >> $file
	echo "${conf[$i_pri]} #app config" >> $file
	echo >> $file
	echo "[global] #generated by the script from outer machine" >> $file
	if [ $max_pri -lt ${pri[$i_pri]} ]; then
	  max_pri=${pri[$i_pri]}
	fi
	
	scp ${apps[${ch[$i_pri]}]}_config_global con0:$APPDIR
    	# adapt the local config file of the control app (CA): each CA has in *massive* directory of con0 the local1/2/3... file, choose one to be the *local*.
    	ssh -n con0 "sh -c 'cd $APPDIR; cp ${apps[${ch[$i_pri]}]}_config_local${conf[$i_pri]} ${apps[${ch[$i_pri]}]}_config_local'"

	if [[ $list_app == "null" ]]; then
          list_app=${apps[${ch[$i_pri]}]}
	else
	  list_app="$list_app ${apps[${ch[$i_pri]}]}"
	fi
	#run controller
	
	#generate traffic at end-point
	#TODO: loop through end-point traffic profile and end-point combination dimensions
	#dump traffic in involved end-points and routers, observe the path
	#stop end-point, stop controller
	#compare trace files with run in isolation to detect anomalies.

      done
      echo "list_app = $list_app"
      bash collectdata_controller.bash $list_app
      bash collectdata_dataplane.bash $point "${comb[0]}" "${comb[1]}" $numsw
      bash collectdata_stop_and_clean.bash $numsw $numep
      exit_code=$?
      [ $exit_code -ne 0 ] && echo "stop and clean error!, exit code $exit_code" && exit 1

      #################################################################################
      # Now compare the expected and real network behaviour. The criteria include: priority,
      # communication state between end-points, the number of rules in the flow table of the
      # highest priority apps, the link bandwidth. Refer to the document/Cuong's dissertation
      # for much more detail.
      #
      #
      #################################################################################
      # First extract the app(s) with highest priority, which is the $max_pri
      #echo "highest priority:max_pri=$max_pri"
      for (( i_pri=0; i_pri<${#pri[@]}; i_pri++ )); do #index priority
        ########################################################
        # uncomment the next line to compare observed and co-deployed network behaviour from 
        # only control apps of highest priority, else all apps are checked
	#[ ${pri[$i_pri]} -lt $max_pri ] && continue
        ########################################################
	if [[ ${apps[${ch[$i_pri]}]} == "eplb" ]]; then
	# check the balance of delivery state at end-point
	  echo "eplb"
	  rep=($(bash collectdata_getEPLBserver.bash)) #get replicas of eplb, e.g., rep=(192.168.1.3 192.168.1.4)
	  for (( i_rep=0; i_rep<${#rep[@]}; i_rep++ )); do #index of replica
	    i_pc=$(echo ${rep[$i_rep]} | cut -d'.' -f4) #index of pc: i_pc=3 / i_pc=4
	    echo "i_pc=$i_pc"
	    iso_count=$(ssh -n pc$i_pc "sh -c 'grep -c ^connect tmpnc_recv_eplb_${conf[$i_pri]}'") #iso = isolated
	    cdp_count=$(ssh -n pc$i_pc "sh -c 'grep -c ^connect tmpnc_recv_$point'") #cdp = co-deployment
	    [ "$iso_count" -ne $cdp_count ] && echo "conflict, eplb is not fulfilled at end-point for nc test, pc$i_pc, iso=$iso_count, cdp=$cdp_count, point=$point" | tee -a $CONFLICT_FILE

	    iso_count=$(ssh -n pc$i_pc "sh -c 'grep -c connected tmpiperf_recv_eplb_${conf[$i_pri]}'") #iso = isolated
	    cdp_count=$(ssh -n pc$i_pc "sh -c 'grep -c connected tmpiperf_recv_$point'") #cdp = co-deployment
	    [ "$iso_count" -ne $cdp_count ] && echo "conflict, eplb is not fulfilled at end-point for iperf test, pc$i_pc, iso=$iso_count, cdp=$cdp_count, point=$point" | tee -a $CONFLICT_FILE
	  done
	  # check rules at target switches, just compare the number of rules installed by eplb
	  tsstr=(${ts[${ch[$i_pri]}]}) #target switch string
	  for (( i_ts=0; i_ts<${#tsstr[@]}; i_ts++ )); do
	    iso_count=$(ssh -n router${tsstr[$i_ts]} "sh -c 'grep -c 0x400 router${tsstr[$i_ts]}\_dumpflows_eplb_${conf[$i_pri]}'")
	    cdp_count=$(ssh -n router${tsstr[$i_ts]} "sh -c 'grep -c 0x400 router${tsstr[$i_ts]}\_dumpflows_$point'")
	    [ "$iso_count" -ne $cdp_count ] && echo "conflict, the number of rules at switch ${tsstr[$i_ts]} by eplb differs between isolated and co-deployed run, iso=$iso_count, cdp=$cdp_count, point=$point" | tee -a $CONFLICT_FILE
	  done

	elif [[ ${apps[${ch[$i_pri]}]} == "hs" ]]; then
	# check the balance of delivery state at end-point
	  echo "hs"
	  rep=($(bash collectdata_getHSserver.bash)) # get all ips in config file for frontend and backend hosts
	  for (( i_rep=0; i_rep<${#rep[@]}; i_rep++ )); do # index of frontend/backend host
	    i_pc=$(echo ${rep[$i_rep]} | cut -d'.' -f4) #index of pc: i_pc=3 / i_pc=4
	    echo "i_pc=$i_pc"
	    iso_count=$(ssh -n pc$i_pc "sh -c 'grep -c ^connect tmpnc_recv_hs_${conf[$i_pri]}'") #iso = isolated
	    cdp_count=$(ssh -n pc$i_pc "sh -c 'grep -c ^connect tmpnc_recv_$point'") #cdp = co-deployment
	    [ "$iso_count" -ne $cdp_count ] && echo "conflict, hs is not fulfilled at end-point for nc test, pc$i_pc, iso=$iso_count, cdp=$cdp_count, point=$point" | tee -a $CONFLICT_FILE

	    iso_count=$(ssh -n pc$i_pc "sh -c 'grep -c connected tmpiperf_recv_hs_${conf[$i_pri]}'") #iso = isolated
	    cdp_count=$(ssh -n pc$i_pc "sh -c 'grep -c connected tmpiperf_recv_$point'") #cdp = co-deployment
	    [ "$iso_count" -ne $cdp_count ] && echo "conflict, hs is not fulfilled at end-point for iperf test, pc$i_pc, iso=$iso_count, cdp=$cdp_count, point=$point" | tee -a $CONFLICT_FILE
	  done
    # TODO get the switches that will contain reverse rewrite rule as target switch
	  # check rules at target switches, just compare the number of rules installed by hs
	  tsstr=(${ts[${ch[$i_pri]}]}) #target switch string
	  for (( i_ts=0; i_ts<${#tsstr[@]}; i_ts++ )); do
	    iso_count=$(ssh -n router${tsstr[$i_ts]} "sh -c 'grep -c 0x440 router${tsstr[$i_ts]}\_dumpflows_hs_${conf[$i_pri]}'")
	    cdp_count=$(ssh -n router${tsstr[$i_ts]} "sh -c 'grep -c 0x440 router${tsstr[$i_ts]}\_dumpflows_$point'")
	    [ "$iso_count" -ne $cdp_count ] && echo "conflict, the number of rules at switch ${tsstr[$i_ts]} by hs differs between isolated and co-deployed run, iso=$iso_count, cdp=$cdp_count, point=$point" | tee -a $CONFLICT_FILE
	  done
	  
	elif [[ ${apps[${ch[$i_pri]}]} == "pplb4s" ]]; then
	# check rules at target switches and their ports' throughput 
	  echo "pplb4s"
	  # check rules at target switches, just compare the number of rules installed by pplb4s
	  tsstr=(${ts[${ch[$i_pri]}]}) #target switch string
	  for (( i_ts=0; i_ts<${#tsstr[@]}; i_ts++ )); do
	    iso_count=$(ssh -n router${tsstr[$i_ts]} "sh -c 'grep -c 0x700 router${tsstr[$i_ts]}\_dumpflows_pplb4s_${conf[$i_pri]}'")
	    cdp_count=$(ssh -n router${tsstr[$i_ts]} "sh -c 'grep -c 0x700 router${tsstr[$i_ts]}\_dumpflows_$point'")
	    [ "$iso_count" -ne $cdp_count ] && echo "conflict, the number of rules at switch ${tsstr[$i_ts]} by pplb4s differs between isolated and co-deployed run, iso=$iso_count, cdp=$cdp_count, point=$point" | tee -a $CONFLICT_FILE
	  # check ports' throughput
            # calculate bw when deploying app in isolation, link bw = max link bw when this all was running.
      	    # Likewise, calculate bw of point, i.e., when apps are deployed together
	    ts_i=${tsstr[$i_ts]}
	    #list_eth=$(ssh -n router$ts_i "tcpdump -D | grep -v eth0| grep eth | cut -c6-6| xargs") 
            list_eth=$(ssh -n router$ts_i "tcpdump -D | grep -v eth0 | grep eth | sed --expression='s/^[0-9]\+.//g' | cut -c4-5 | xargs") #correct until eth99
	    #list ethernet in form, e.g., "1 2 3"
	    echo "list_eth = $list_eth"
	    for eth in $list_eth; do
	      echo "filename = router"$ts_i"_eth"$eth"_pplb4s_"${conf[$i_pri]}".txt"
 	      tmp=$(ssh -n router$ts_i "bash calculate_max_bw_from_netbps_script.bash router"$ts_i"_eth"$eth"_pplb4s_"${conf[$i_pri]}".txt")
	      echo "tmp bw = $tmp"
	      #echo "iso_bw_r[$ts_i,$eth] = ${iso_bw_r[$ts_i,$eth]}" # isolation bandwidth router
	      [ -z ${iso_bw_r[$ts_i,$eth]} ] && declare -A iso_bw_r[$ts_i,$eth] && iso_bw_r[$ts_i,$eth]=0
              #If you do not declare the array as associative (with -A), the above will not work. See https://stackoverflow.com/questions/11233825/multi-dimensional-arrays-in-bash/31468914
	      compare ${iso_bw_r[$ts_i,$eth]} $tmp
	      [[ $? -eq 1 ]] && iso_bw_r[$ts_i,$eth]=$tmp #isolation bw router iso_bw_r
	      #echo "current bw of iso_bw_r[$ts_i,$eth] = ${iso_bw_r[$ts_i,$eth]}"

	      # Now, calculate bw in co-deployment, i.e., at current point.
              bw_r[$ts_i,$eth]=$(ssh -n router$ts_i "bash calculate_max_bw_from_netbps_script.bash router"$ts_i"_eth"$eth"_"$point".txt") 
              echo "bw when deploying apps in isolation of router[$ts_i,$eth] = ${iso_bw_r[$ts_i,$eth]}"
              echo "bw when deploying apps together of router[$ts_i,$eth] = ${bw_r[$ts_i,$eth]}"
              tmp1=$(abs $(bc -l <<< "${iso_bw_r[$ts_i,$eth]} - ${bw_r[$ts_i,$eth]}" ))
              echo "bw difference = $tmp1"
              compare $tmp1 5
              [ $? -eq 0 ] && (echo "conflict, bw difference=$tmp1, point=$point,router$ts_i, eth$eth" | tee -a conflict.txt) || echo "no problem"
	    done
	  done
	
	elif [[ ${apps[${ch[$i_pri]}]} == "pplb4d" ]]; then
	# check rules at target switches and their ports' throughput
	  echo "pplb4d"
	  tsstr=(${ts[${ch[$i_pri]}]}) #target switch string
	  for (( i_ts=0; i_ts<${#tsstr[@]}; i_ts++ )); do
	  # check rules at target switches, just compare the number of rules installed by pplb4d
	    iso_count=$(ssh -n router${tsstr[$i_ts]} "sh -c 'grep -c 0x900 router${tsstr[$i_ts]}\_dumpflows_pplb4d_${conf[$i_pri]}'")
	    cdp_count=$(ssh -n router${tsstr[$i_ts]} "sh -c 'grep -c 0x900 router${tsstr[$i_ts]}\_dumpflows_$point'")
	    [ "$iso_count" -ne $cdp_count ] && echo "conflict, the number of rules at switch ${tsstr[$i_ts]} by pplb4d differs between isolated and co-deployed run, iso=$iso_count, cdp=$cdp_count, point=$point" | tee -a $CONFLICT_FILE
	  # check ports' throughput
            # calculate bw when deploying app in isolation, link bw = max link bw when this all was running.
      	    # Likewise, calculate bw of point, i.e., when apps are deployed together
	    ts_i=${tsstr[$i_ts]}
	    #list_eth=$(ssh -n router$ts_i "tcpdump -D | grep -v eth0| grep eth | cut -c6-6| xargs") 
            list_eth=$(ssh -n router$ts_i "tcpdump -D | grep -v eth0 | grep eth | sed --expression='s/^[0-9]\+.//g' | cut -c4-5 | xargs") #correct until eth99
	    #list ethernet in form, e.g., "1 2 3"
	    echo "list_eth = $list_eth"
	    for eth in $list_eth; do
	      echo "filename = router"$ts_i"_eth"$eth"_pplb4d_"${conf[$i_pri]}".txt"
 	      tmp=$(ssh -n router$ts_i "bash calculate_max_bw_from_netbps_script.bash router"$ts_i"_eth"$eth"_pplb4d_"${conf[$i_pri]}".txt")
	      echo "tmp bw = $tmp"
	      #echo "iso_bw_r[$ts_i,$eth] = ${iso_bw_r[$ts_i,$eth]}" # isolation bandwidth router
	      [ -z ${iso_bw_r[$ts_i,$eth]} ] && declare -A iso_bw_r[$ts_i,$eth] && iso_bw_r[$ts_i,$eth]=0
              #If you do not declare the array as associative (with -A), the above will not work. See https://stackoverflow.com/questions/11233825/multi-dimensional-arrays-in-bash/31468914
	      compare ${iso_bw_r[$ts_i,$eth]} $tmp
	      [[ $? -eq 1 ]] && iso_bw_r[$ts_i,$eth]=$tmp #isolation bw router iso_bw_r
	      #echo "current bw of iso_bw_r[$ts_i,$eth] = ${iso_bw_r[$ts_i,$eth]}"

	      # Now, calculate bw in co-deployment, i.e., at current point.
              bw_r[$ts_i,$eth]=$(ssh -n router$ts_i "bash calculate_max_bw_from_netbps_script.bash router"$ts_i"_eth"$eth"_"$point".txt")
              echo "bw when deploying apps in isolation of router[$ts_i,$eth] = ${iso_bw_r[$ts_i,$eth]}"
              echo "bw when deploying apps together of router[$ts_i,$eth] = ${bw_r[$ts_i,$eth]}"
              tmp1=$(abs $(bc -l <<< "${iso_bw_r[$ts_i,$eth]} - ${bw_r[$ts_i,$eth]}" ))
              echo "bw difference = $tmp1"
              compare $tmp1 5
              [ $? -eq 0 ] && (echo "conflict, bw difference=$tmp1, point=$point,router$ts_i, eth$eth" | tee -a conflict.txt) || echo "no problem"
	    done
	  done

	elif [[ ${apps[${ch[$i_pri]}]} == "pe" ]]; then
	# check rules at target switches and their ports' throughput
	  echo "pe"
	  tsstr=(${ts[${ch[$i_pri]}]}) # target switch string
    echo "pe target string"
	  jumpSwitches=$(bash collectdata_getPEjumps.bash) # TODO test add jumps in config to target switch string
    jumpSwitches=($jumpSwitches)
    tsstr=("${tsstr[@]}" "${jumpSwitches[@]}")
    echo "${tsstr[@]}"
	  for (( i_ts=0; i_ts<${#tsstr[@]}; i_ts++ )); do
	  # check rules at target switches, just compare the number of rules installed by pplb4d
	    iso_count=$(ssh -n router${tsstr[$i_ts]} "sh -c 'grep -c 0x990 router${tsstr[$i_ts]}\_dumpflows_pe_${conf[$i_pri]}'")
	    cdp_count=$(ssh -n router${tsstr[$i_ts]} "sh -c 'grep -c 0x990 router${tsstr[$i_ts]}\_dumpflows_$point'")
	    [ "$iso_count" -ne $cdp_count ] && echo "conflict, the number of rules at switch ${tsstr[$i_ts]} by pe differs between isolated and co-deployed run, iso=$iso_count, cdp=$cdp_count, point=$point" | tee -a $CONFLICT_FILE
	  # check ports' throughput
            # calculate bw when deploying app in isolation, link bw = max link bw when this all was running.
      	    # Likewise, calculate bw of point, i.e., when apps are deployed together
	    ts_i=${tsstr[$i_ts]}
	    #list_eth=$(ssh -n router$ts_i "tcpdump -D | grep -v eth0| grep eth | cut -c6-6| xargs") #correct only if a router has up to eth8, wrong from eth9..
            list_eth=$(ssh -n router$ts_i "tcpdump -D | grep -v eth0 | grep eth | sed --expression='s/^[0-9]\+.//g' | cut -c4-5 | xargs") #correct until eth99
	    #list ethernet in form, e.g., "1 2 3"
	    echo "list_eth = $list_eth"
	    for eth in $list_eth; do
	      echo "filename = router"$ts_i"_eth"$eth"_pe_"${conf[$i_pri]}".txt"
 	      tmp=$(ssh -n router$ts_i "bash calculate_max_bw_from_netbps_script.bash router"$ts_i"_eth"$eth"_pe_"${conf[$i_pri]}".txt")
	      echo "tmp bw = $tmp"
	      #echo "iso_bw_r[$ts_i,$eth] = ${iso_bw_r[$ts_i,$eth]}" # isolation bandwidth router
	      [ -z ${iso_bw_r[$ts_i,$eth]} ] && declare -A iso_bw_r[$ts_i,$eth] && iso_bw_r[$ts_i,$eth]=0
              #If you do not declare the array as associative (with -A), the above will not work. See https://stackoverflow.com/questions/11233825/multi-dimensional-arrays-in-bash/31468914
	      compare ${iso_bw_r[$ts_i,$eth]} $tmp
	      [[ $? -eq 1 ]] && iso_bw_r[$ts_i,$eth]=$tmp #isolation bw router iso_bw_r
	      #echo "current bw of iso_bw_r[$ts_i,$eth] = ${iso_bw_r[$ts_i,$eth]}"

	      # Now, calculate bw in co-deployment, i.e., at current point.
              bw_r[$ts_i,$eth]=$(ssh -n router$ts_i "bash calculate_max_bw_from_netbps_script.bash router"$ts_i"_eth"$eth"_"$point".txt")
              echo "bw when deploying apps in isolation of router[$ts_i,$eth] = ${iso_bw_r[$ts_i,$eth]}"
              echo "bw when deploying apps together of router[$ts_i,$eth] = ${bw_r[$ts_i,$eth]}"
              tmp1=$(abs $(bc -l <<< "${iso_bw_r[$ts_i,$eth]} - ${bw_r[$ts_i,$eth]}" ))
              echo "bw difference = $tmp1"
              compare $tmp1 5
              [ $? -eq 0 ] && (echo "conflict, bw difference=$tmp1, point=$point,router$ts_i, eth$eth" | tee -a conflict.txt) || echo "no problem"
	    done
	  done

	elif [[ ${apps[${ch[$i_pri]}]} == "plb" ]]; then
	  echo "plb" #not yet processed
	elif [[ ${apps[${ch[$i_pri]}]} == "routing" ]]; then
	  echo "routing" #not yet processed
	elif [[ ${apps[${ch[$i_pri]}]} == "fw" ]]; then
	  echo "fw" #not yet processed
	else
	  echo "unknown app, error!"
	fi
        #echo "${apps[${ch[$i_pri]}]}:${conf[$i_pri]}:${pri[$i_pri]}:${ts[${ch[$i_pri]}]}" | tee -a all_config
	#echo "Point $point: Generating config for ${apps[${ch[$i_pri]}]}"
	#file=${apps[${ch[$i_pri]}]}_config_global
	#echo "${pri[$i_pri]} #priority" > $file
	#echo "${ts[${ch[$i_pri]}]} #target switches" >> $file
	#echo "${conf[$i_pri]} #app config" >> $file
      done


: '
      #TODO analyse trace file: bw_monitor and flow tables
      # current list of apps is in $list_app
      # current config for each app is in $conf
      # compare bw
      # calculate bw when deploying apps in isolation, link bw = max link bw from all apps.
      for (( i_cf=0; i_cf<${#conf[@]}; i_cf++ )); do #index config
        echo "i_cf = $i_cf, ch[i_cf] = ${ch[$i_cf]}"
        echo "${ch[$i_cf]}: ${apps[${ch[$i_cf]}]}:${conf[$i_cf]}"
	echo "${ts[${ch[$i_cf]}]} #target switches"
	[ "${ts[${ch[$i_cf]}]}" = "all" ] && echo "target switch = all, continue" && continue
	#TODO: should it be so, to loop through all combination of switches as in parameter space? Currently, only loop through switches explicitly pertaining to an app.
	for ts_i in ${ts[${ch[$i_cf]}]}; do #target switch element
	  list_eth=$(ssh -n router$ts_i "tcpdump -D | grep -v eth0| grep eth | cut -c6-6| xargs") 
	  #list ethernet in form, e.g., "1 2 3"
	  echo "list_eth = $list_eth"
	  for eth in $list_eth; do
	    echo "filename = router"$ts_i"_eth"$eth"_"${apps[${ch[$i_cf]}]}"_"${conf[$i_cf]}".txt"
 	    tmp=$(ssh -n router$ts_i "bash calculate_max_bw_from_netbps_script.bash router"$ts_i"_eth"$eth"_"${apps[${ch[$i_cf]}]}"_"${conf[$i_cf]}".txt")
	    echo "tmp bw = $tmp"
	    echo "iso_bw_r[$ts_i,$eth] = ${iso_bw_r[$ts_i,$eth]}"
	    [ -z ${iso_bw_r[$ts_i,$eth]} ] && declare -A iso_bw_r[$ts_i,$eth] && iso_bw_r[$ts_i,$eth]=0
            #If you do not declare the array as associative (with -A), the above will not work. See https://stackoverflow.com/questions/11233825/multi-dimensional-arrays-in-bash/31468914
	    compare ${iso_bw_r[$ts_i,$eth]} $tmp
	    [[ $? -eq 1 ]] && iso_bw_r[$ts_i,$eth]=$tmp #isolation bw router iso_bw_r
	    echo "current bw of iso_bw_r[$ts_i,$eth] = ${iso_bw_r[$ts_i,$eth]}"
	  done
	done
      done

      #calculate bw of point, i.e., when apps are deployed together
      for (( i_cf=0; i_cf<${#conf[@]}; i_cf++ )); do #index config, index here is merely index, no special meaning, the variable name could be i, j ... not necessarily i_cf, just a reuse here.
	echo "target switch = ${ts[${ch[$i_cf]}]}"
	[ "${ts[${ch[$i_cf]}]}" = "all" ] && echo "target switch = all, continue" && continue
        for ts_i in ${ts[${ch[$i_cf]}]}; do #target switch element
          list_eth=$(ssh -n router$ts_i "tcpdump -D | grep -v eth0| grep eth | cut -c6-6| xargs") #list ethernet in form, e.g., "1 2 3"
          for eth in $list_eth; do
            bw_r[$ts_i,$eth]=$(ssh -n router$ts_i "bash calculate_max_bw_from_netbps_script.bash router"$ts_i"_eth"$eth"_"$point".txt")
            echo "bw when deploying apps in isolation of router[$ts_i,$eth] = ${iso_bw_r[$ts_i,$eth]}"
            echo "bw when deploying apps together of router[$ts_i,$eth] = ${bw_r[$ts_i,$eth]}"
            tmp=$(abs $(bc -l <<< "${iso_bw_r[$ts_i,$eth]} - ${bw_r[$ts_i,$eth]}" ))
            echo "bw difference = $tmp"
            compare $tmp 5
            [ $? -eq 0 ] && (echo "conflict, bw difference=$tmp, point=$point,router$ts_i, eth$eth" | tee -a conflict.txt) || echo "no problem"
          done
        done
      done
'      
#      [ $point -eq 2 ] && exit
      let point++

    done < "priority${#conf[@]}"

  done < "app_config"

done < "app_choice"

echo Experiment finished at $(date +"%y%m%d_%H%M%S") | tee -a conflict.txt

# store data in the dataset
mkdir -p dataset/$id
cp all_config conflict.txt -t dataset/$id

echo "Store router*_dumpflows_* from all routers/switches in the dataset"
for i in $(seq 1 $numsw); do echo -n "router$i "; ssh -n router$i "sh -c 'tar zcf router$i\_dumpflows.tar.gz router$i\_dumpflows_*'";scp router$i:router$i\_dumpflows.tar.gz dataset/$id; done

# upload results to remote machine if config file was inserted when topology was generated
mkdir -p sdn_results
cp parameter_space.json -t dataset/"$id"
scp con0:massive/detector_log dataset/"$id" || echo "No detector log on con0!"
ssh -n con0 "sh -c 'rm /root/massive/detector_log'" || echo "No detector log to delete!"
ssh -F ~/.ssh/sdn_config sdn "mkdir -p sdn_results" || echo "Failed to ssh to remote machine!"
scp -p -F ~/.ssh/sdn_config -r dataset/"$id" sdn:sdn_results || exit 0
rm -r dataset/"$id"

